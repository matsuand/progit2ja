# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-02-04 19:16+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:3
#, no-wrap
msgid ""
"[[_advanced_merging]]\n"
"=== Advanced Merging\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:6
#, no-wrap
msgid ""
"Merging in Git is typically fairly easy.\n"
"Since Git makes it easy to merge another branch multiple times, it means "
"that you can have a very long lived branch but you can keep it up to date as "
"you go, solving small conflicts often, rather than be surprised by one "
"enormous conflict at the end of the series.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:11
#, no-wrap
msgid ""
"However, sometimes tricky conflicts do occur.\n"
"Unlike some other version control systems, Git does not try to be overly "
"clever about merge conflict resolution.\n"
"Git's philosophy is to be smart about determining when a merge resolution is "
"unambiguous, but if there is a conflict, it does not try to be clever about "
"automatically resolving it.\n"
"Therefore, if you wait too long to merge two branches that diverge quickly, "
"you can run into some issues.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:14
#, no-wrap
msgid ""
"In this section, we'll go over what some of those issues might be and what "
"tools Git gives you to help handle these more tricky situations.\n"
"We'll also cover some of the different, non-standard types of merges you can "
"do, as well as see how to back out of merges that you've done.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:16
#, no-wrap
msgid "==== Merge Conflicts\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:18
#, no-wrap
msgid ""
"While we covered some basics on resolving merge conflicts in "
"<<ch03-git-branching#_basic_merge_conflicts>>, for more complex conflicts, "
"Git provides a few tools to help you figure out what's going on and how to "
"better deal with the conflict.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:23
#, no-wrap
msgid ""
"First of all, if at all possible, try to make sure your working directory is "
"clean before doing a merge that may have conflicts.\n"
"If you have work in progress, either commit it to a temporary branch or "
"stash it.\n"
"This makes it so that you can undo *anything* you try here.\n"
"If you have unsaved changes in your working directory when you try a merge, "
"some of these tips may help you preserve that work.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:26
#, no-wrap
msgid ""
"Let's walk through a very simple example.\n"
"We have a super simple Ruby file that prints 'hello world'.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:28
#: book/07-git-tools/sections/advanced-merging.asc:340
#: book/07-git-tools/sections/advanced-merging.asc:375
#: book/07-git-tools/sections/credentials.asc:166
#: book/07-git-tools/sections/rerere.asc:31
#: book/07-git-tools/sections/rerere.asc:181
#, no-wrap
msgid ""
"[source,ruby]\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:30
#: book/07-git-tools/sections/advanced-merging.asc:342
#: book/07-git-tools/sections/advanced-merging.asc:377
#: book/07-git-tools/sections/rerere.asc:33
#: book/07-git-tools/sections/rerere.asc:183
#, no-wrap
msgid "#! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:34
#, no-wrap
msgid ""
"def hello\n"
"  puts 'hello world'\n"
"end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:36
#: book/07-git-tools/sections/advanced-merging.asc:352
#: book/07-git-tools/sections/advanced-merging.asc:389
#, no-wrap
msgid ""
"hello()\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:40
#, no-wrap
msgid ""
"In our repository, we create a new branch named `whitespace` and proceed to "
"change all the Unix line endings to DOS line endings, essentially changing "
"every line of the file, but just with whitespace.\n"
"Then we change the line \"`hello world`\" to \"`hello mundo`\".\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:42
#: book/07-git-tools/sections/advanced-merging.asc:76
#: book/07-git-tools/sections/advanced-merging.asc:102
#: book/07-git-tools/sections/advanced-merging.asc:117
#: book/07-git-tools/sections/advanced-merging.asc:145
#: book/07-git-tools/sections/advanced-merging.asc:177
#: book/07-git-tools/sections/advanced-merging.asc:186
#: book/07-git-tools/sections/advanced-merging.asc:198
#: book/07-git-tools/sections/advanced-merging.asc:232
#: book/07-git-tools/sections/advanced-merging.asc:256
#: book/07-git-tools/sections/advanced-merging.asc:275
#: book/07-git-tools/sections/advanced-merging.asc:297
#: book/07-git-tools/sections/advanced-merging.asc:313
#: book/07-git-tools/sections/advanced-merging.asc:329
#: book/07-git-tools/sections/advanced-merging.asc:368
#: book/07-git-tools/sections/advanced-merging.asc:394
#: book/07-git-tools/sections/advanced-merging.asc:412
#: book/07-git-tools/sections/advanced-merging.asc:428
#: book/07-git-tools/sections/advanced-merging.asc:445
#: book/07-git-tools/sections/advanced-merging.asc:474
#: book/07-git-tools/sections/advanced-merging.asc:500
#: book/07-git-tools/sections/advanced-merging.asc:569
#: book/07-git-tools/sections/advanced-merging.asc:587
#: book/07-git-tools/sections/advanced-merging.asc:601
#: book/07-git-tools/sections/advanced-merging.asc:634
#: book/07-git-tools/sections/advanced-merging.asc:645
#: book/07-git-tools/sections/advanced-merging.asc:668
#: book/07-git-tools/sections/bundling.asc:20
#: book/07-git-tools/sections/bundling.asc:38
#: book/07-git-tools/sections/bundling.asc:57
#: book/07-git-tools/sections/bundling.asc:72
#: book/07-git-tools/sections/bundling.asc:91
#: book/07-git-tools/sections/bundling.asc:102
#: book/07-git-tools/sections/bundling.asc:118
#: book/07-git-tools/sections/bundling.asc:131
#: book/07-git-tools/sections/bundling.asc:141
#: book/07-git-tools/sections/bundling.asc:151
#: book/07-git-tools/sections/bundling.asc:160
#: book/07-git-tools/sections/credentials.asc:28
#: book/07-git-tools/sections/credentials.asc:38
#: book/07-git-tools/sections/credentials.asc:64
#: book/07-git-tools/sections/credentials.asc:120
#: book/07-git-tools/sections/credentials.asc:182
#: book/07-git-tools/sections/credentials.asc:197
#: book/07-git-tools/sections/debugging.asc:16
#: book/07-git-tools/sections/debugging.asc:48
#: book/07-git-tools/sections/debugging.asc:83
#: book/07-git-tools/sections/debugging.asc:97
#: book/07-git-tools/sections/debugging.asc:107
#: book/07-git-tools/sections/debugging.asc:117
#: book/07-git-tools/sections/debugging.asc:133
#: book/07-git-tools/sections/debugging.asc:143
#: book/07-git-tools/sections/interactive-staging.asc:11
#: book/07-git-tools/sections/interactive-staging.asc:34
#: book/07-git-tools/sections/interactive-staging.asc:46
#: book/07-git-tools/sections/interactive-staging.asc:59
#: book/07-git-tools/sections/interactive-staging.asc:77
#: book/07-git-tools/sections/interactive-staging.asc:98
#: book/07-git-tools/sections/interactive-staging.asc:114
#: book/07-git-tools/sections/interactive-staging.asc:146
#: book/07-git-tools/sections/interactive-staging.asc:167
#: book/07-git-tools/sections/interactive-staging.asc:188
#: book/07-git-tools/sections/replace.asc:19
#: book/07-git-tools/sections/replace.asc:37
#: book/07-git-tools/sections/replace.asc:52
#: book/07-git-tools/sections/replace.asc:70
#: book/07-git-tools/sections/replace.asc:87
#: book/07-git-tools/sections/replace.asc:106
#: book/07-git-tools/sections/replace.asc:122
#: book/07-git-tools/sections/replace.asc:140
#: book/07-git-tools/sections/replace.asc:157
#: book/07-git-tools/sections/replace.asc:164
#: book/07-git-tools/sections/replace.asc:181
#: book/07-git-tools/sections/replace.asc:196
#: book/07-git-tools/sections/rerere.asc:21
#: book/07-git-tools/sections/rerere.asc:46
#: book/07-git-tools/sections/rerere.asc:60
#: book/07-git-tools/sections/rerere.asc:74
#: book/07-git-tools/sections/rerere.asc:82
#: book/07-git-tools/sections/rerere.asc:105
#: book/07-git-tools/sections/rerere.asc:115
#: book/07-git-tools/sections/rerere.asc:137
#: book/07-git-tools/sections/rerere.asc:152
#: book/07-git-tools/sections/rerere.asc:161
#: book/07-git-tools/sections/rerere.asc:192
#: book/07-git-tools/sections/rerere.asc:213
#: book/07-git-tools/sections/rerere.asc:231
#: book/07-git-tools/sections/rerere.asc:246
#: book/07-git-tools/sections/reset.asc:35
#: book/07-git-tools/sections/reset.asc:61
#: book/07-git-tools/sections/reset.asc:80
#: book/07-git-tools/sections/revision-selection.asc:19
#: book/07-git-tools/sections/revision-selection.asc:45
#: book/07-git-tools/sections/revision-selection.asc:55
#: book/07-git-tools/sections/revision-selection.asc:98
#: book/07-git-tools/sections/revision-selection.asc:109
#: book/07-git-tools/sections/revision-selection.asc:122
#: book/07-git-tools/sections/revision-selection.asc:138
#: book/07-git-tools/sections/revision-selection.asc:146
#: book/07-git-tools/sections/revision-selection.asc:156
#: book/07-git-tools/sections/revision-selection.asc:193
#: book/07-git-tools/sections/revision-selection.asc:208
#: book/07-git-tools/sections/revision-selection.asc:223
#: book/07-git-tools/sections/revision-selection.asc:241
#: book/07-git-tools/sections/revision-selection.asc:253
#: book/07-git-tools/sections/revision-selection.asc:276
#: book/07-git-tools/sections/revision-selection.asc:288
#: book/07-git-tools/sections/revision-selection.asc:320
#: book/07-git-tools/sections/revision-selection.asc:330
#: book/07-git-tools/sections/revision-selection.asc:340
#: book/07-git-tools/sections/revision-selection.asc:356
#: book/07-git-tools/sections/revision-selection.asc:366
#: book/07-git-tools/sections/revision-selection.asc:381
#: book/07-git-tools/sections/revision-selection.asc:395
#: book/07-git-tools/sections/rewriting-history.asc:28
#: book/07-git-tools/sections/rewriting-history.asc:49
#: book/07-git-tools/sections/rewriting-history.asc:68
#: book/07-git-tools/sections/rewriting-history.asc:78
#: book/07-git-tools/sections/rewriting-history.asc:114
#: book/07-git-tools/sections/rewriting-history.asc:131
#: book/07-git-tools/sections/rewriting-history.asc:140
#: book/07-git-tools/sections/rewriting-history.asc:156
#: book/07-git-tools/sections/rewriting-history.asc:164
#: book/07-git-tools/sections/rewriting-history.asc:178
#: book/07-git-tools/sections/rewriting-history.asc:187
#: book/07-git-tools/sections/rewriting-history.asc:202
#: book/07-git-tools/sections/rewriting-history.asc:233
#: book/07-git-tools/sections/rewriting-history.asc:242
#: book/07-git-tools/sections/rewriting-history.asc:266
#: book/07-git-tools/sections/rewriting-history.asc:278
#: book/07-git-tools/sections/rewriting-history.asc:290
#: book/07-git-tools/sections/rewriting-history.asc:308
#: book/07-git-tools/sections/rewriting-history.asc:353
#: book/07-git-tools/sections/rewriting-history.asc:373
#: book/07-git-tools/sections/rewriting-history.asc:389
#: book/07-git-tools/sections/searching.asc:18
#: book/07-git-tools/sections/searching.asc:38
#: book/07-git-tools/sections/searching.asc:50
#: book/07-git-tools/sections/searching.asc:66
#: book/07-git-tools/sections/searching.asc:102
#: book/07-git-tools/sections/searching.asc:121
#: book/07-git-tools/sections/signing.asc:12
#: book/07-git-tools/sections/signing.asc:24
#: book/07-git-tools/sections/signing.asc:31
#: book/07-git-tools/sections/signing.asc:43
#: book/07-git-tools/sections/signing.asc:54
#: book/07-git-tools/sections/signing.asc:87
#: book/07-git-tools/sections/signing.asc:106
#: book/07-git-tools/sections/signing.asc:119
#: book/07-git-tools/sections/signing.asc:135
#: book/07-git-tools/sections/signing.asc:149
#: book/07-git-tools/sections/signing.asc:165
#: book/07-git-tools/sections/signing.asc:173
#: book/07-git-tools/sections/signing.asc:186
#: book/07-git-tools/sections/stashing-cleaning.asc:26
#: book/07-git-tools/sections/stashing-cleaning.asc:44
#: book/07-git-tools/sections/stashing-cleaning.asc:55
#: book/07-git-tools/sections/stashing-cleaning.asc:65
#: book/07-git-tools/sections/stashing-cleaning.asc:78
#: book/07-git-tools/sections/stashing-cleaning.asc:102
#: book/07-git-tools/sections/stashing-cleaning.asc:121
#: book/07-git-tools/sections/stashing-cleaning.asc:139
#: book/07-git-tools/sections/stashing-cleaning.asc:158
#: book/07-git-tools/sections/stashing-cleaning.asc:175
#: book/07-git-tools/sections/stashing-cleaning.asc:204
#: book/07-git-tools/sections/stashing-cleaning.asc:244
#: book/07-git-tools/sections/stashing-cleaning.asc:255
#: book/07-git-tools/sections/stashing-cleaning.asc:277
#: book/07-git-tools/sections/submodules.asc:29
#: book/07-git-tools/sections/submodules.asc:45
#: book/07-git-tools/sections/submodules.asc:84
#: book/07-git-tools/sections/submodules.asc:101
#: book/07-git-tools/sections/submodules.asc:118
#: book/07-git-tools/sections/submodules.asc:132
#: book/07-git-tools/sections/submodules.asc:143
#: book/07-git-tools/sections/submodules.asc:172
#: book/07-git-tools/sections/submodules.asc:191
#: book/07-git-tools/sections/submodules.asc:224
#: book/07-git-tools/sections/submodules.asc:240
#: book/07-git-tools/sections/submodules.asc:254
#: book/07-git-tools/sections/submodules.asc:271
#: book/07-git-tools/sections/submodules.asc:289
#: book/07-git-tools/sections/submodules.asc:307
#: book/07-git-tools/sections/submodules.asc:330
#: book/07-git-tools/sections/submodules.asc:352
#: book/07-git-tools/sections/submodules.asc:385
#: book/07-git-tools/sections/submodules.asc:425
#: book/07-git-tools/sections/submodules.asc:448
#: book/07-git-tools/sections/submodules.asc:475
#: book/07-git-tools/sections/submodules.asc:486
#: book/07-git-tools/sections/submodules.asc:506
#: book/07-git-tools/sections/submodules.asc:517
#: book/07-git-tools/sections/submodules.asc:528
#: book/07-git-tools/sections/submodules.asc:538
#: book/07-git-tools/sections/submodules.asc:556
#: book/07-git-tools/sections/submodules.asc:574
#: book/07-git-tools/sections/submodules.asc:592
#: book/07-git-tools/sections/submodules.asc:616
#: book/07-git-tools/sections/submodules.asc:650
#: book/07-git-tools/sections/submodules.asc:674
#: book/07-git-tools/sections/submodules.asc:694
#: book/07-git-tools/sections/submodules.asc:712
#: book/07-git-tools/sections/submodules.asc:753
#: book/07-git-tools/sections/submodules.asc:774
#: book/07-git-tools/sections/submodules.asc:800
#: book/07-git-tools/sections/submodules.asc:812
#: book/07-git-tools/sections/submodules.asc:824
#: book/07-git-tools/sections/submodules.asc:868
#: book/07-git-tools/sections/submodules.asc:886
#: book/07-git-tools/sections/submodules.asc:923
#: book/07-git-tools/sections/submodules.asc:944
#: book/07-git-tools/sections/submodules.asc:989
#: book/07-git-tools/sections/submodules.asc:999
#: book/07-git-tools/sections/submodules.asc:1014
#: book/07-git-tools/sections/submodules.asc:1027
#: book/07-git-tools/sections/subtree-merges.asc:13
#: book/07-git-tools/sections/subtree-merges.asc:36
#: book/07-git-tools/sections/subtree-merges.asc:56
#: book/07-git-tools/sections/subtree-merges.asc:65
#: book/07-git-tools/sections/subtree-merges.asc:75
#: book/07-git-tools/sections/subtree-merges.asc:94
#: book/07-git-tools/sections/subtree-merges.asc:101
#, no-wrap
msgid ""
"[source,console]\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:45
#, no-wrap
msgid ""
"$ git checkout -b whitespace\n"
"Switched to a new branch 'whitespace'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:51
#, no-wrap
msgid ""
"$ unix2dos hello.rb\n"
"unix2dos: converting file hello.rb to DOS format ...\n"
"$ git commit -am 'Convert hello.rb to DOS'\n"
"[whitespace 3270f76] Convert hello.rb to DOS\n"
" 1 file changed, 7 insertions(+), 7 deletions(-)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:60
#, no-wrap
msgid ""
"$ vim hello.rb\n"
"$ git diff -b\n"
"diff --git a/hello.rb b/hello.rb\n"
"index ac51efd..e85207e 100755\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@ -1,7 +1,7 @@\n"
" #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:65
#, no-wrap
msgid ""
" def hello\n"
"-  puts 'hello world'\n"
"+  puts 'hello mundo'^M\n"
" end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:67
#, no-wrap
msgid " hello()\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:71
#, no-wrap
msgid ""
"$ git commit -am 'Use Spanish instead of English'\n"
"[whitespace 6d338d2] Use Spanish instead of English\n"
" 1 file changed, 1 insertion(+), 1 deletion(-)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:74
#, no-wrap
msgid ""
"Now we switch back to our `master` branch and add some documentation for the "
"function.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:79
#, no-wrap
msgid ""
"$ git checkout master\n"
"Switched to branch 'master'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:88
#, no-wrap
msgid ""
"$ vim hello.rb\n"
"$ git diff\n"
"diff --git a/hello.rb b/hello.rb\n"
"index ac51efd..36c06c8 100755\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@ -1,5 +1,6 @@\n"
" #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:93
#, no-wrap
msgid ""
"+# prints out a greeting\n"
" def hello\n"
"   puts 'hello world'\n"
" end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:97
#, no-wrap
msgid ""
"$ git commit -am 'Add comment documenting the function'\n"
"[master bec6336] Add comment documenting the function\n"
" 1 file changed, 1 insertion(+)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:100
#, no-wrap
msgid ""
"Now we try to merge in our `whitespace` branch and we'll get conflicts "
"because of the whitespace changes.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:107
#, no-wrap
msgid ""
"$ git merge whitespace\n"
"Auto-merging hello.rb\n"
"CONFLICT (content): Merge conflict in hello.rb\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:111
#, no-wrap
msgid ""
"[[_abort_merge]]\n"
"===== Aborting a Merge\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:115
#, no-wrap
msgid ""
"We now have a few options.\n"
"First, let's cover how to get out of this situation.\n"
"If you perhaps weren't expecting conflicts and don't want to quite deal with "
"the situation yet, you can simply back out of the merge with `git merge "
"--abort`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:121
#, no-wrap
msgid ""
"$ git status -sb\n"
"## master\n"
"UU hello.rb\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:123
#, no-wrap
msgid "$ git merge --abort\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:126
#, no-wrap
msgid ""
"$ git status -sb\n"
"## master\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:130
#, no-wrap
msgid ""
"The `git merge --abort` option tries to revert back to your state before you "
"ran the merge.\n"
"The only cases where it may not be able to do this perfectly would be if you "
"had unstashed, uncommitted changes in your working directory when you ran "
"it, otherwise it should work fine.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:133
#, no-wrap
msgid ""
"If for some reason you just want to start over, you can also run `git reset "
"--hard HEAD`, and your repository will be back to the last committed "
"state.\n"
"Remember that any uncommitted work will be lost, so make sure you don't want "
"any of your changes.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:135
#, no-wrap
msgid "===== Ignoring Whitespace\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:139
#, no-wrap
msgid ""
"In this specific case, the conflicts are whitespace related.\n"
"We know this because the case is simple, but it's also pretty easy to tell "
"in real cases when looking at the conflict because every line is removed on "
"one side and added again on the other.\n"
"By default, Git sees all of these lines as being changed, so it can't merge "
"the files.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:143
#, no-wrap
msgid ""
"The default merge strategy can take arguments though, and a few of them are "
"about properly ignoring whitespace changes.\n"
"If you see that you have a lot of whitespace issues in a merge, you can "
"simply abort it and do it again, this time with `-Xignore-all-space` or "
"`-Xignore-space-change`.\n"
"The first option ignores whitespace *completely* when comparing lines, the "
"second treats sequences of one or more whitespace characters as "
"equivalent.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:151
#, no-wrap
msgid ""
"$ git merge -Xignore-space-change whitespace\n"
"Auto-merging hello.rb\n"
"Merge made by the 'recursive' strategy.\n"
" hello.rb | 2 +-\n"
" 1 file changed, 1 insertion(+), 1 deletion(-)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:154
#, no-wrap
msgid ""
"Since in this case, the actual file changes were not conflicting, once we "
"ignore the whitespace changes, everything merges just fine.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:156
#, no-wrap
msgid ""
"This is a lifesaver if you have someone on your team who likes to "
"occasionally reformat everything from spaces to tabs or vice-versa.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:159
#, no-wrap
msgid ""
"[[_manual_remerge]]\n"
"===== Manual File Re-merging\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:162
#, no-wrap
msgid ""
"Though Git handles whitespace pre-processing pretty well, there are other "
"types of changes that perhaps Git can't handle automatically, but are "
"scriptable fixes.\n"
"As an example, let's pretend that Git could not handle the whitespace change "
"and we needed to do it by hand.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:165
#, no-wrap
msgid ""
"What we really need to do is run the file we're trying to merge in through a "
"`dos2unix` program before trying the actual file merge.\n"
"So how would we do that?\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:169
#, no-wrap
msgid ""
"First, we get into the merge conflict state.\n"
"Then we want to get copies of my version of the file, their version (from "
"the branch we're merging in) and the common version (from where both sides "
"branched off).\n"
"Then we want to fix up either their side or our side and re-try the merge "
"again for just this single file.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:173
#, no-wrap
msgid ""
"Getting the three file versions is actually pretty easy.\n"
"Git stores all of these versions in the index under \"`stages`\" which each "
"have numbers associated with them.\n"
"Stage 1 is the common ancestor, stage 2 is your version and stage 3 is from "
"the `MERGE_HEAD`, the version you're merging in (\"`theirs`\").\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:175
#, no-wrap
msgid ""
"You can extract a copy of each of these versions of the conflicted file with "
"the `git show` command and a special syntax.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:181
#, no-wrap
msgid ""
"$ git show :1:hello.rb > hello.common.rb\n"
"$ git show :2:hello.rb > hello.ours.rb\n"
"$ git show :3:hello.rb > hello.theirs.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:184
#, no-wrap
msgid ""
"If you want to get a little more hard core, you can also use the `ls-files "
"-u` plumbing command to get the actual SHA-1s of the Git blobs for each of "
"these files.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:191
#, no-wrap
msgid ""
"$ git ls-files -u\n"
"100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1\thello.rb\n"
"100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2\thello.rb\n"
"100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3\thello.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:194
#, no-wrap
msgid "The `:1:hello.rb` is just a shorthand for looking up that blob SHA-1.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:196
#, no-wrap
msgid ""
"Now that we have the content of all three stages in our working directory, "
"we can manually fix up theirs to fix the whitespace issue and re-merge the "
"file with the little-known `git merge-file` command which does just that.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:201
#, no-wrap
msgid ""
"$ dos2unix hello.theirs.rb\n"
"dos2unix: converting file hello.theirs.rb to Unix format ...\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:204
#, no-wrap
msgid ""
"$ git merge-file -p \\\n"
"    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:212
#, no-wrap
msgid ""
"$ git diff -b\n"
"diff --cc hello.rb\n"
"index 36c06c8,e85207e..0000000\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@@ -1,8 -1,7 +1,8 @@@\n"
"  #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:218
#, no-wrap
msgid ""
" +# prints out a greeting\n"
"  def hello\n"
"-   puts 'hello world'\n"
"+   puts 'hello mundo'\n"
"  end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:220
#: book/07-git-tools/sections/advanced-merging.asc:463
#: book/07-git-tools/sections/advanced-merging.asc:491
#: book/07-git-tools/sections/advanced-merging.asc:526
#, no-wrap
msgid ""
"  hello()\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:225
#, no-wrap
msgid ""
"At this point we have nicely merged the file.\n"
"In fact, this actually works better than the `ignore-space-change` option "
"because this actually fixes the whitespace changes before merge instead of "
"simply ignoring them.\n"
"In the `ignore-space-change` merge, we actually ended up with a few lines "
"with DOS line endings, making things mixed.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:228
#, no-wrap
msgid ""
"If you want to get an idea before finalizing this commit about what was "
"actually changed between one side or the other, you can ask `git diff` to "
"compare what is in your working directory that you're about to commit as the "
"result of the merge to any of these stages.\n"
"Let's go through them all.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:230
#, no-wrap
msgid ""
"To compare your result to what you had in your branch before the merge, in "
"other words, to see what the merge introduced, you can run `git diff "
"--ours`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:240
#, no-wrap
msgid ""
"$ git diff --ours\n"
"* Unmerged path hello.rb\n"
"diff --git a/hello.rb b/hello.rb\n"
"index 36c06c8..44d0a25 100755\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@ -2,7 +2,7 @@\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:246
#, no-wrap
msgid ""
" # prints out a greeting\n"
" def hello\n"
"-  puts 'hello world'\n"
"+  puts 'hello mundo'\n"
" end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:248
#: book/07-git-tools/sections/advanced-merging.asc:292
#, no-wrap
msgid ""
" hello()\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:251
#, no-wrap
msgid ""
"So here we can easily see that what happened in our branch, what we're "
"actually introducing to this file with this merge, is changing that single "
"line.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:254
#, no-wrap
msgid ""
"If we want to see how the result of the merge differed from what was on "
"their side, you can run `git diff --theirs`.\n"
"In this and the following example, we have to use `-b` to strip out the "
"whitespace because we're comparing it to what is in Git, not our cleaned up "
"`hello.theirs.rb` file.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:265
#, no-wrap
msgid ""
"$ git diff --theirs -b\n"
"* Unmerged path hello.rb\n"
"diff --git a/hello.rb b/hello.rb\n"
"index e85207e..44d0a25 100755\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@ -1,5 +1,6 @@\n"
" #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:270
#, no-wrap
msgid ""
"+# prints out a greeting\n"
" def hello\n"
"   puts 'hello mundo'\n"
" end\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:273
#, no-wrap
msgid ""
"Finally, you can see how the file has changed from both sides with `git diff "
"--base`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:284
#, no-wrap
msgid ""
"$ git diff --base -b\n"
"* Unmerged path hello.rb\n"
"diff --git a/hello.rb b/hello.rb\n"
"index ac51efd..44d0a25 100755\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@ -1,7 +1,8 @@\n"
" #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:290
#, no-wrap
msgid ""
"+# prints out a greeting\n"
" def hello\n"
"-  puts 'hello world'\n"
"+  puts 'hello mundo'\n"
" end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:295
#, no-wrap
msgid ""
"At this point we can use the `git clean` command to clear out the extra "
"files we created to do the manual merge but no longer need.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:302
#, no-wrap
msgid ""
"$ git clean -f\n"
"Removing hello.common.rb\n"
"Removing hello.ours.rb\n"
"Removing hello.theirs.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:306
#, no-wrap
msgid ""
"[[_checking_out_conflicts]]\n"
"===== Checking Out Conflicts\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:308
#, no-wrap
msgid ""
"Perhaps we're not happy with the resolution at this point for some reason, "
"or maybe manually editing one or both sides still didn't work well and we "
"need more context.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:311
#, no-wrap
msgid ""
"Let's change up the example a little.\n"
"For this example, we have two longer lived branches that each have a few "
"commits in them but create a legitimate content conflict when merged.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:323
#, no-wrap
msgid ""
"$ git log --graph --oneline --decorate --all\n"
"* f1270f7 (HEAD, master) Update README\n"
"* 9af9d3b Create README\n"
"* 694971d Update phrase to 'hola world'\n"
"| * e3eb223 (mundo) Add more tests\n"
"| * 7cff591 Create initial testing script\n"
"| * c3ffff1 Change text to 'hello mundo'\n"
"|/\n"
"* b7dcc89 Initial hello world code\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:327
#, no-wrap
msgid ""
"We now have three unique commits that live only on the `master` branch and "
"three others that live on the `mundo` branch.\n"
"If we try to merge the `mundo` branch in, we get a conflict.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:334
#, no-wrap
msgid ""
"$ git merge mundo\n"
"Auto-merging hello.rb\n"
"CONFLICT (content): Merge conflict in hello.rb\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:338
#, no-wrap
msgid ""
"We would like to see what the merge conflict is.\n"
"If we open up the file, we'll see something like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:346
#, no-wrap
msgid ""
"def hello\n"
"<<<<<<< HEAD\n"
"  puts 'hola world'\n"
"=======\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:350
#, no-wrap
msgid ""
"  puts 'hello mundo'\n"
">>>>>>> mundo\n"
"end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:355
#, no-wrap
msgid ""
"Both sides of the merge added content to this file, but some of the commits "
"modified the file in the same place that caused this conflict.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:359
#, no-wrap
msgid ""
"Let's explore a couple of tools that you now have at your disposal to "
"determine how this conflict came to be.\n"
"Perhaps it's not obvious how exactly you should fix this conflict.\n"
"You need more context.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:363
#, no-wrap
msgid ""
"One helpful tool is `git checkout` with the `--conflict` option.\n"
"This will re-checkout the file again and replace the merge conflict "
"markers.\n"
"This can be useful if you want to reset the markers and try to resolve them "
"again.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:366
#, no-wrap
msgid ""
"You can pass `--conflict` either `diff3` or `merge` (which is the "
"default).\n"
"If you pass it `diff3`, Git will use a slightly different version of "
"conflict markers, not only giving you the \"`ours`\" and \"`theirs`\" "
"versions, but also the \"`base`\" version inline to give you more context.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:370
#, no-wrap
msgid ""
"$ git checkout --conflict=diff3 hello.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:373
#, no-wrap
msgid "Once we run that, the file will look like this instead:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:383
#, no-wrap
msgid ""
"def hello\n"
"<<<<<<< ours\n"
"  puts 'hola world'\n"
"||||||| base\n"
"  puts 'hello world'\n"
"=======\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:387
#, no-wrap
msgid ""
"  puts 'hello mundo'\n"
">>>>>>> theirs\n"
"end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:392
#, no-wrap
msgid ""
"If you like this format, you can set it as the default for future merge "
"conflicts by setting the `merge.conflictstyle` setting to `diff3`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:396
#, no-wrap
msgid ""
"$ git config --global merge.conflictstyle diff3\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:399
#, no-wrap
msgid ""
"The `git checkout` command can also take `--ours` and `--theirs` options, "
"which can be a really fast way of just choosing either one side or the other "
"without merging things at all.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:401
#, no-wrap
msgid ""
"This can be particularly useful for conflicts of binary files where you can "
"simply choose one side, or where you only want to merge certain files in "
"from another branch -- you can do the merge and then checkout certain files "
"from one side or the other before committing.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:404
#, no-wrap
msgid ""
"[[_merge_log]]\n"
"===== Merge Log\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:408
#, no-wrap
msgid ""
"Another useful tool when resolving merge conflicts is `git log`.\n"
"This can help you get context on what may have contributed to the "
"conflicts.\n"
"Reviewing a little bit of history to remember why two lines of development "
"were touching the same area of code can be really helpful sometimes.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:410
#, no-wrap
msgid ""
"To get a full list of all of the unique commits that were included in either "
"branch involved in this merge, we can use the \"`triple dot`\" syntax that "
"we learned in <<ch07-git-tools#_triple_dot>>.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:420
#, no-wrap
msgid ""
"$ git log --oneline --left-right HEAD...MERGE_HEAD\n"
"< f1270f7 Update README\n"
"< 9af9d3b Create README\n"
"< 694971d Update phrase to 'hola world'\n"
"> e3eb223 Add more tests\n"
"> 7cff591 Create initial testing script\n"
"> c3ffff1 Change text to 'hello mundo'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:423
#, no-wrap
msgid ""
"That's a nice list of the six total commits involved, as well as which line "
"of development each commit was on.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:426
#, no-wrap
msgid ""
"We can further simplify this though to give us much more specific context.\n"
"If we add the `--merge` option to `git log`, it will only show the commits "
"in either side of the merge that touch a file that's currently conflicted.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:432
#, no-wrap
msgid ""
"$ git log --oneline --left-right --merge\n"
"< 694971d Update phrase to 'hola world'\n"
"> c3ffff1 Change text to 'hello mundo'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:436
#, no-wrap
msgid ""
"If you run that with the `-p` option instead, you get just the diffs to the "
"file that ended up in conflict.\n"
"This can be *really* helpful in quickly giving you the context you need to "
"help understand why something conflicts and how to more intelligently "
"resolve it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:438
#, no-wrap
msgid "===== Combined Diff Format\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:441
#, no-wrap
msgid ""
"Since Git stages any merge results that are successful, when you run `git "
"diff` while in a conflicted merge state, you only get what is currently "
"still in conflict.\n"
"This can be helpful to see what you still have to resolve.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:443
#, no-wrap
msgid ""
"When you run `git diff` directly after a merge conflict, it will give you "
"information in a rather unique diff output format.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:453
#, no-wrap
msgid ""
"$ git diff\n"
"diff --cc hello.rb\n"
"index 0399cd5,59727f0..0000000\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@@ -1,7 -1,7 +1,11 @@@\n"
"  #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:461
#, no-wrap
msgid ""
"  def hello\n"
"++<<<<<<< HEAD\n"
" +  puts 'hola world'\n"
"++=======\n"
"+   puts 'hello mundo'\n"
"++>>>>>>> mundo\n"
"  end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:467
#, no-wrap
msgid ""
"The format is called \"`Combined Diff`\" and gives you two columns of data "
"next to each line.\n"
"The first column shows you if that line is different (added or removed) "
"between the \"`ours`\" branch and the file in your working directory and the "
"second column does the same between the \"`theirs`\" branch and your working "
"directory copy.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:470
#, no-wrap
msgid ""
"So in that example you can see that the `<<<<<<<` and `>>>>>>>` lines are in "
"the working copy but were not in either side of the merge.\n"
"This makes sense because the merge tool stuck them in there for our context, "
"but we're expected to remove them.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:472
#, no-wrap
msgid ""
"If we resolve the conflict and run `git diff` again, we'll see the same "
"thing, but it's a little more useful.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:483
#, no-wrap
msgid ""
"$ vim hello.rb\n"
"$ git diff\n"
"diff --cc hello.rb\n"
"index 0399cd5,59727f0..0000000\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@@ -1,7 -1,7 +1,7 @@@\n"
"  #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:489
#: book/07-git-tools/sections/advanced-merging.asc:524
#, no-wrap
msgid ""
"  def hello\n"
"-   puts 'hola world'\n"
" -  puts 'hello mundo'\n"
"++  puts 'hola mundo'\n"
"  end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:495
#, no-wrap
msgid ""
"This shows us that \"`hola world`\" was in our side but not in the working "
"copy, that \"`hello mundo`\" was in their side but not in the working copy "
"and finally that \"`hola mundo`\" was not in either side but is now in the "
"working copy.\n"
"This can be useful to review before committing the resolution.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:498
#, no-wrap
msgid ""
"You can also get this from the `git log` for any merge to see how something "
"was resolved after the fact.\n"
"Git will output this format if you run `git show` on a merge commit, or if "
"you add a `--cc` option to a `git log -p` (which by default only shows "
"patches for non-merge commits).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:506
#, no-wrap
msgid ""
"$ git log --cc -p -1\n"
"commit 14f41939956d80b9e17bb8721354c33f8d5b5a79\n"
"Merge: f1270f7 e3eb223\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Fri Sep 19 18:14:49 2014 +0200\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:508
#, no-wrap
msgid "    Merge branch 'mundo'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:511
#, no-wrap
msgid ""
"    Conflicts:\n"
"        hello.rb\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:518
#, no-wrap
msgid ""
"diff --cc hello.rb\n"
"index 0399cd5,59727f0..e1d0799\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@@ -1,7 -1,7 +1,7 @@@\n"
"  #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:530
#, no-wrap
msgid ""
"[[_undoing_merges]]\n"
"==== Undoing Merges\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:533
#, no-wrap
msgid ""
"Now that you know how to create a merge commit, you'll probably make some by "
"mistake.\n"
"One of the great things about working with Git is that it's okay to make "
"mistakes, because it's possible (and in many cases easy) to fix them.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:536
#, no-wrap
msgid ""
"Merge commits are no different.\n"
"Let's say you started work on a topic branch, accidentally merged it into "
"`master`, and now your commit history looks like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:539
#, no-wrap
msgid ""
".Accidental merge commit\n"
"image::images/undomerge-start.png[Accidental merge commit]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:541
#, no-wrap
msgid ""
"There are two ways to approach this problem, depending on what your desired "
"outcome is.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:543
#, no-wrap
msgid "===== Fix the references\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:546
#, no-wrap
msgid ""
"If the unwanted merge commit only exists on your local repository, the "
"easiest and best solution is to move the branches so that they point where "
"you want them to.\n"
"In most cases, if you follow the errant `git merge` with `git reset --hard "
"HEAD~`, this will reset the branch pointers so they look like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:549
#, no-wrap
msgid ""
".History after `git reset --hard HEAD~`\n"
"image::images/undomerge-reset.png[History after `git reset --hard HEAD~`]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:552
#, no-wrap
msgid ""
"We covered `reset` back in <<ch07-git-tools#_git_reset>>, so it shouldn't be "
"too hard to figure out what's going on here.\n"
"Here's a quick refresher: `reset --hard` usually goes through three steps:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:557
#, no-wrap
msgid ""
". Move the branch HEAD points to.\n"
"  In this case, we want to move `master` to where it was before the merge "
"commit (`C6`).\n"
". Make the index look like HEAD.\n"
". Make the working directory look like the index.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:561
#, no-wrap
msgid ""
"The downside of this approach is that it's rewriting history, which can be "
"problematic with a shared repository.\n"
"Check out <<ch03-git-branching#_rebase_peril>> for more on what can happen; "
"the short version is that if other people have the commits you're rewriting, "
"you should probably avoid `reset`.\n"
"This approach also won't work if any other commits have been created since "
"the merge; moving the refs would effectively lose those changes.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:564
#, no-wrap
msgid ""
"[[_reverse_commit]]\n"
"===== Reverse the commit\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:567
#, no-wrap
msgid ""
"If moving the branch pointers around isn't going to work for you, Git gives "
"you the option of making a new commit which undoes all the changes from an "
"existing one.\n"
"Git calls this operation a \"`revert`\", and in this particular scenario, "
"you'd invoke it like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:572
#, no-wrap
msgid ""
"$ git revert -m 1 HEAD\n"
"[master b1d8379] Revert \"Merge branch 'topic'\"\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:577
#, no-wrap
msgid ""
"The `-m 1` flag indicates which parent is the \"`mainline`\" and should be "
"kept.\n"
"When you invoke a merge into `HEAD` (`git merge topic`), the new commit has "
"two parents: the first one is `HEAD` (`C6`), and the second is the tip of "
"the branch being merged in (`C4`).\n"
"In this case, we want to undo all the changes introduced by merging in "
"parent #2 (`C4`), while keeping all the content from parent #1 (`C6`).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:579
#, no-wrap
msgid "The history with the revert commit looks like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:582
#, no-wrap
msgid ""
".History after `git revert -m 1`\n"
"image::images/undomerge-revert.png[History after `git revert -m 1`]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:585
#, no-wrap
msgid ""
"The new commit `^M` has exactly the same contents as `C6`, so starting from "
"here it's as if the merge never happened, except that the now-unmerged "
"commits are still in `HEAD`âs history.\n"
"Git will get confused if you try to merge `topic` into `master` again:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:590
#, no-wrap
msgid ""
"$ git merge topic\n"
"Already up-to-date.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:594
#, no-wrap
msgid ""
"There's nothing in `topic` that isn't already reachable from `master`.\n"
"What's worse, if you add work to `topic` and merge again, Git will only "
"bring in the changes _since_ the reverted merge:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:597
#, no-wrap
msgid ""
".History with a bad merge\n"
"image::images/undomerge-revert2.png[History with a bad merge]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:599
#, no-wrap
msgid ""
"The best way around this is to un-revert the original merge, since now you "
"want to bring in the changes that were reverted out, *then* create a new "
"merge commit:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:605
#, no-wrap
msgid ""
"$ git revert ^M\n"
"[master 09f0126] Revert \"Revert \"Merge branch 'topic'\"\"\n"
"$ git merge topic\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:609
#, no-wrap
msgid ""
".History after re-merging a reverted merge\n"
"image::images/undomerge-revert3.png[History after re-merging a reverted "
"merge]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:612
#, no-wrap
msgid ""
"In this example, `M` and `^M` cancel out.\n"
"`^^M` effectively merges in the changes from `C3` and `C4`, and `C8` merges "
"in the changes from `C7`, so now `topic` is fully merged.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:614
#, no-wrap
msgid "==== Other Types of Merges\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:618
#, no-wrap
msgid ""
"So far we've covered the normal merge of two branches, normally handled with "
"what is called the \"`recursive`\" strategy of merging.\n"
"There are other ways to merge branches together however.\n"
"Let's cover a few of them quickly.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:620
#, no-wrap
msgid "===== Our or Theirs Preference\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:623
#, no-wrap
msgid ""
"First of all, there is another useful thing we can do with the normal "
"\"`recursive`\" mode of merging.\n"
"We've already seen the `ignore-all-space` and `ignore-space-change` options "
"which are passed with a `-X` but we can also tell Git to favor one side or "
"the other when it sees a conflict.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:626
#, no-wrap
msgid ""
"By default, when Git sees a conflict between two branches being merged, it "
"will add merge conflict markers into your code and mark the file as "
"conflicted and let you resolve it.\n"
"If you would prefer for Git to simply choose a specific side and ignore the "
"other side instead of letting you manually resolve the conflict, you can "
"pass the `merge` command either a `-Xours` or `-Xtheirs`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:630
#, no-wrap
msgid ""
"If Git sees this, it will not add conflict markers.\n"
"Any differences that are mergeable, it will merge.\n"
"Any differences that conflict, it will simply choose the side you specify in "
"whole, including binary files.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:632
#, no-wrap
msgid ""
"If we go back to the \"`hello world`\" example we were using before, we can "
"see that merging in our branch causes conflicts.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:640
#, no-wrap
msgid ""
"$ git merge mundo\n"
"Auto-merging hello.rb\n"
"CONFLICT (content): Merge conflict in hello.rb\n"
"Resolved 'hello.rb' using previous resolution.\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:643
#, no-wrap
msgid "However if we run it with `-Xours` or `-Xtheirs` it does not.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:653
#, no-wrap
msgid ""
"$ git merge -Xours mundo\n"
"Auto-merging hello.rb\n"
"Merge made by the 'recursive' strategy.\n"
" hello.rb | 2 +-\n"
" test.sh  | 2 ++\n"
" 2 files changed, 3 insertions(+), 1 deletion(-)\n"
" create mode 100644 test.sh\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:657
#, no-wrap
msgid ""
"In that case, instead of getting conflict markers in the file with \"`hello "
"mundo`\" on one side and \"`hola world`\" on the other, it will simply pick "
"\"`hola world`\".\n"
"However, all the other non-conflicting changes on that branch are merged "
"successfully in.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:659
#, no-wrap
msgid ""
"This option can also be passed to the `git merge-file` command we saw "
"earlier by running something like `git merge-file --ours` for individual "
"file merges.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:662
#, no-wrap
msgid ""
"If you want to do something like this but not have Git even try to merge "
"changes from the other side in, there is a more draconian option, which is "
"the \"`ours`\" merge _strategy_.\n"
"This is different from the \"`ours`\" recursive merge _option_.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:666
#, no-wrap
msgid ""
"This will basically do a fake merge.\n"
"It will record a new merge commit with both branches as parents, but it will "
"not even look at the branch you're merging in.\n"
"It will simply record as the result of the merge the exact code in your "
"current branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:673
#, no-wrap
msgid ""
"$ git merge -s ours mundo\n"
"Merge made by the 'ours' strategy.\n"
"$ git diff HEAD HEAD~\n"
"$\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:676
#, no-wrap
msgid ""
"You can see that there is no difference between the branch we were on and "
"the result of the merge.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:681
#, no-wrap
msgid ""
"This can often be useful to basically trick Git into thinking that a branch "
"is already merged when doing a merge later on.\n"
"For example, say you branched off a `release` branch and have done some work "
"on it that you will want to merge back into your `master` branch at some "
"point.\n"
"In the meantime some bugfix on `master` needs to be backported into your "
"`release` branch.\n"
"You can merge the bugfix branch into the `release` branch and also `merge -s "
"ours` the same branch into your `master` branch (even though the fix is "
"already there) so when you later merge the `release` branch again, there are "
"no conflicts from the bugfix.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/advanced-merging.asc:682
#, no-wrap
msgid "include::subtree-merges.asc[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:3
#, no-wrap
msgid ""
"[[_bundling]]\n"
"=== Bundling\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:5
#, no-wrap
msgid ""
"Though we've covered the common ways to transfer Git data over a network "
"(HTTP, SSH, etc), there is actually one more way to do so that is not "
"commonly used but can actually be quite useful.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:12
#, no-wrap
msgid ""
"Git is capable of \"`bundling`\" its data into a single file.\n"
"This can be useful in various scenarios.\n"
"Maybe your network is down and you want to send changes to your "
"co-workers.\n"
"Perhaps you're working somewhere offsite and don't have access to the local "
"network for security reasons.\n"
"Maybe your wireless/ethernet card just broke.\n"
"Maybe you don't have access to a shared server for the moment, you want to "
"email someone updates and you don't want to transfer 40 commits via "
"`format-patch`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:15
#, no-wrap
msgid ""
"This is where the `git bundle` command can be helpful.\n"
"The `bundle` command will package up everything that would normally be "
"pushed over the wire with a `git push` command into a binary file that you "
"can email to someone or put on a flash drive, then unbundle into another "
"repository.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:18
#, no-wrap
msgid ""
"Let's see a simple example.\n"
"Let's say you have a repository with two commits:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:25
#, no-wrap
msgid ""
"$ git log\n"
"commit 9a466c572fe88b195efd356c3f2bbeccdb504102\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Wed Mar 10 07:34:10 2010 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:27
#, no-wrap
msgid "    Second commit\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:31
#, no-wrap
msgid ""
"commit b1ec3248f39900d2a406049d762aa68e9641be25\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Wed Mar 10 07:34:01 2010 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:33
#, no-wrap
msgid ""
"    First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:36
#, no-wrap
msgid ""
"If you want to send that repository to someone and you don't have access to "
"a repository to push to, or simply don't want to set one up, you can bundle "
"it with `git bundle create`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:45
#, no-wrap
msgid ""
"$ git bundle create repo.bundle HEAD master\n"
"Counting objects: 6, done.\n"
"Delta compression using up to 2 threads.\n"
"Compressing objects: 100% (2/2), done.\n"
"Writing objects: 100% (6/6), 441 bytes, done.\n"
"Total 6 (delta 0), reused 0 (delta 0)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:50
#, no-wrap
msgid ""
"Now you have a file named `repo.bundle` that has all the data needed to "
"re-create the repository's `master` branch.\n"
"With the `bundle` command you need to list out every reference or specific "
"range of commits that you want to be included.\n"
"If you intend for this to be cloned somewhere else, you should add HEAD as a "
"reference as well as we've done here.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:52
#, no-wrap
msgid ""
"You can email this `repo.bundle` file to someone else, or put it on a USB "
"drive and walk it over.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:55
#, no-wrap
msgid ""
"On the other side, say you are sent this `repo.bundle` file and want to work "
"on the project.\n"
"You can clone from the binary file into a directory, much like you would "
"from a URL.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:65
#, no-wrap
msgid ""
"$ git clone repo.bundle repo\n"
"Cloning into 'repo'...\n"
"...\n"
"$ cd repo\n"
"$ git log --oneline\n"
"9a466c5 Second commit\n"
"b1ec324 First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:68
#, no-wrap
msgid ""
"If you don't include HEAD in the references, you have to also specify `-b "
"master` or whatever branch is included because otherwise it won't know what "
"branch to check out.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:70
#, no-wrap
msgid ""
"Now let's say you do three commits on it and want to send the new commits "
"back via a bundle on a USB stick or email.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:79
#, no-wrap
msgid ""
"$ git log --oneline\n"
"71b84da Last commit - second repo\n"
"c99cf5b Fourth commit - second repo\n"
"7011d3d Third commit - second repo\n"
"9a466c5 Second commit\n"
"b1ec324 First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:84
#, no-wrap
msgid ""
"First we need to determine the range of commits we want to include in the "
"bundle.\n"
"Unlike the network protocols which figure out the minimum set of data to "
"transfer over the network for us, we'll have to figure this out manually.\n"
" Now, you could just do the same thing and bundle the entire repository, "
"which will work, but it's better to just bundle up the difference - just the "
"three commits we just made locally.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:89
#, no-wrap
msgid ""
"In order to do that, you'll have to calculate the difference.\n"
"As we described in <<ch07-git-tools#_commit_ranges>>, you can specify a "
"range of commits in a number of ways.\n"
"To get the three commits that we have in our `master` branch that weren't in "
"the branch we originally cloned, we can use something like "
"`origin/master..master` or `master ^origin/master`.\n"
"You can test that with the `log` command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:96
#, no-wrap
msgid ""
"$ git log --oneline master ^origin/master\n"
"71b84da Last commit - second repo\n"
"c99cf5b Fourth commit - second repo\n"
"7011d3d Third commit - second repo\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:100
#, no-wrap
msgid ""
"So now that we have the list of commits we want to include in the bundle, "
"let's bundle them up.\n"
"We do that with the `git bundle create` command, giving it a filename we "
"want our bundle to be and the range of commits we want to go into it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:109
#, no-wrap
msgid ""
"$ git bundle create commits.bundle master ^9a466c5\n"
"Counting objects: 11, done.\n"
"Delta compression using up to 2 threads.\n"
"Compressing objects: 100% (3/3), done.\n"
"Writing objects: 100% (9/9), 775 bytes, done.\n"
"Total 9 (delta 0), reused 0 (delta 0)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:113
#, no-wrap
msgid ""
"Now we have a `commits.bundle` file in our directory.\n"
"If we take that and send it to our partner, she can then import it into the "
"original repository, even if more work has been done there in the "
"meantime.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:116
#, no-wrap
msgid ""
"When she gets the bundle, she can inspect it to see what it contains before "
"she imports it into her repository.\n"
"The first command is the `bundle verify` command that will make sure the "
"file is actually a valid Git bundle and that you have all the necessary "
"ancestors to reconstitute it properly.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:125
#, no-wrap
msgid ""
"$ git bundle verify ../commits.bundle\n"
"The bundle contains 1 ref\n"
"71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master\n"
"The bundle requires these 1 ref\n"
"9a466c572fe88b195efd356c3f2bbeccdb504102 second commit\n"
"../commits.bundle is okay\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:129
#, no-wrap
msgid ""
"If the bundler had created a bundle of just the last two commits they had "
"done, rather than all three, the original repository would not be able to "
"import it, since it is missing requisite history.\n"
"The `verify` command would have looked like this instead:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:135
#, no-wrap
msgid ""
"$ git bundle verify ../commits-bad.bundle\n"
"error: Repository lacks these prerequisite commits:\n"
"error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 Third commit - second repo\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:139
#, no-wrap
msgid ""
"However, our first bundle is valid, so we can fetch in commits from it.\n"
"If you want to see what branches are in the bundle that can be imported, "
"there is also a command to just list the heads:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:144
#, no-wrap
msgid ""
"$ git bundle list-heads ../commits.bundle\n"
"71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:149
#, no-wrap
msgid ""
"The `verify` sub-command will tell you the heads as well.\n"
"The point is to see what can be pulled in, so you can use the `fetch` or "
"`pull` commands to import commits from this bundle.\n"
"Here we'll fetch the `master` branch of the bundle to a branch named "
"`other-master` in our repository:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:155
#, no-wrap
msgid ""
"$ git fetch ../commits.bundle master:other-master\n"
"From ../commits.bundle\n"
" * [new branch]      master     -> other-master\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:158
#, no-wrap
msgid ""
"Now we can see that we have the imported commits on the `other-master` "
"branch as well as any commits we've done in the meantime in our own `master` "
"branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:169
#, no-wrap
msgid ""
"$ git log --oneline --decorate --graph --all\n"
"* 8255d41 (HEAD, master) Third commit - first repo\n"
"| * 71b84da (other-master) Last commit - second repo\n"
"| * c99cf5b Fourth commit - second repo\n"
"| * 7011d3d Third commit - second repo\n"
"|/\n"
"* 9a466c5 Second commit\n"
"* b1ec324 First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/bundling.asc:171
#, no-wrap
msgid ""
"So, `git bundle` can be really useful for sharing or doing network-type "
"operations when you don't have the proper network or shared repository to do "
"so.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:3
#, no-wrap
msgid ""
"[[_credential_caching]]\n"
"=== Credential Storage\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:9
#, no-wrap
msgid ""
"(((credentials)))\n"
"(((git commands, credential)))\n"
"If you use the SSH transport for connecting to remotes, it's possible for "
"you to have a key without a passphrase, which allows you to securely "
"transfer data without typing in your username and password.\n"
"However, this isn't possible with the HTTP protocols â every connection "
"needs a username and password.\n"
"This gets even harder for systems with two-factor authentication, where the "
"token you use for a password is randomly generated and unpronounceable.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:12
#, no-wrap
msgid ""
"Fortunately, Git has a credentials system that can help with this.\n"
"Git has a few options provided in the box:\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/credentials.asc:24
#, markdown-text, no-wrap
msgid ""
"The default is not to cache at all.\n"
"Every connection will prompt you for your username and password.\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/credentials.asc:24
#, markdown-text, no-wrap
msgid ""
"The \"`cache`\" mode keeps credentials in memory for a certain period of "
"time.\n"
"None of the passwords are ever stored on disk, and they are purged from the "
"cache after 15 minutes.\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/credentials.asc:24
#, markdown-text, no-wrap
msgid ""
"The \"`store`\" mode saves the credentials to a plain-text file on disk, and "
"they never expire.\n"
"This means that until you change your password for the Git host, you won't "
"ever have to type in your credentials again.\n"
"The downside of this approach is that your passwords are stored in cleartext "
"in a plain file in your home directory.\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/credentials.asc:24
#, markdown-text, no-wrap
msgid ""
"If you're using a Mac, Git comes with an \"`osxkeychain`\" mode, which "
"caches credentials in the secure keychain that's attached to your system "
"account.\n"
"This method stores the credentials on disk, and they never expire, but "
"they're encrypted with the same system that stores HTTPS certificates and "
"Safari auto-fills.\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/credentials.asc:24
#, markdown-text, no-wrap
msgid ""
"If you're using Windows, macOS, or Linux, you can install a helper called "
"https://github.com/GitCredentialManager/git-credential-manager[\"`Git "
"Credential Manager`\"].\n"
"This uses platform-native data stores to control sensitive information.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:26
#, no-wrap
msgid "You can choose one of these methods by setting a Git configuration value:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:30
#, no-wrap
msgid ""
"$ git config --global credential.helper cache\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:36
#, no-wrap
msgid ""
"Some of these helpers have options.\n"
"The \"`store`\" helper can take a `--file <path>` argument, which customizes "
"where the plain-text file is saved (the default is `~/.git-credentials`).\n"
"The \"`cache`\" helper accepts the `--timeout <seconds>` option, which "
"changes the amount of time its daemon is kept running (the default is "
"\"`900`\", or 15 minutes).\n"
"Here's an example of how you'd configure the \"`store`\" helper with a "
"custom file name:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:40
#, no-wrap
msgid ""
"$ git config --global credential.helper 'store --file ~/.my-credentials'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:46
#, no-wrap
msgid ""
"Git even allows you to configure several helpers.\n"
"When looking for credentials for a particular host, Git will query them in "
"order, and stop after the first answer is provided.\n"
"When saving credentials, Git will send the username and password to *all* of "
"the helpers in the list, and they can choose what to do with them.\n"
"Here's what a `.gitconfig` would look like if you had a credentials file on "
"a thumb drive, but wanted to use the in-memory cache to save some typing if "
"the drive isn't plugged in:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:48
#: book/07-git-tools/sections/credentials.asc:142
#: book/07-git-tools/sections/submodules.asc:61
#, no-wrap
msgid ""
"[source,ini]\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:52
#, no-wrap
msgid ""
"[credential]\n"
"    helper = store --file /mnt/thumbdrive/.git-credentials\n"
"    helper = cache --timeout 30000\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:55
#, no-wrap
msgid "==== Under the Hood\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:58
#, no-wrap
msgid ""
"How does this all work?\n"
"Git's root command for the credential-helper system is `git credential`, "
"which takes a command as an argument, and then more input through stdin.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:62
#, no-wrap
msgid ""
"This might be easier to understand with an example.\n"
"Let's say that a credential helper has been configured, and the helper has "
"stored credentials for `mygithost`.\n"
"Here's a session that uses the \"`fill`\" command, which is invoked when Git "
"is trying to find credentials for a host:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:76
#, no-wrap
msgid ""
"$ git credential fill <1>\n"
"protocol=https <2>\n"
"host=mygithost\n"
"<3>\n"
"protocol=https <4>\n"
"host=mygithost\n"
"username=bob\n"
"password=s3cre7\n"
"$ git credential fill <5>\n"
"protocol=https\n"
"host=unknownhost\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:83
#, no-wrap
msgid ""
"Username for 'https://unknownhost': bob\n"
"Password for 'https://bob@unknownhost':\n"
"protocol=https\n"
"host=unknownhost\n"
"username=bob\n"
"password=s3cre7\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:91
#, no-wrap
msgid ""
"<1> This is the command line that initiates the interaction.\n"
"<2> Git-credential is then waiting for input on stdin.\n"
"    We provide it with the things we know: the protocol and hostname.\n"
"<3> A blank line indicates that the input is complete, and the credential "
"system should answer with what it knows.\n"
"<4> Git-credential then takes over, and writes to stdout with the bits of "
"information it found.\n"
"<5> If credentials are not found, Git asks the user for the username and "
"password, and provides them back to the invoking stdout (here they're "
"attached to the same console).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:94
#, no-wrap
msgid ""
"The credential system is actually invoking a program that's separate from "
"Git itself; which one and how depends on the `credential.helper` "
"configuration value.\n"
"There are several forms it can take:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:103
#, no-wrap
msgid ""
"[options=\"header\"]\n"
"|======\n"
"| Configuration Value | Behavior\n"
"| `foo` | Runs `git-credential-foo`\n"
"| `foo -a --opt=bcd` | Runs `git-credential-foo -a --opt=bcd`\n"
"| `/absolute/path/foo -xyz` | Runs `/absolute/path/foo -xyz`\n"
"| `!f() { echo \"password=s3cre7\"; }; f` | Code after `!` evaluated in "
"shell\n"
"|======\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:107
#, no-wrap
msgid ""
"So the helpers described above are actually named `git-credential-cache`, "
"`git-credential-store`, and so on, and we can configure them to take "
"command-line arguments.\n"
"The general form for this is \"`git-credential-foo [args] <action>.`\"\n"
"The stdin/stdout protocol is the same as git-credential, but they use a "
"slightly different set of actions:\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/credentials.asc:111
#, markdown-text, no-wrap
msgid "`get` is a request for a username/password pair.\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/credentials.asc:111
#, markdown-text, no-wrap
msgid "`store` is a request to save a set of credentials in this helper's memory.\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/credentials.asc:111
#, markdown-text, no-wrap
msgid ""
"`erase` purge the credentials for the given properties from this helper's "
"memory.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:116
#, no-wrap
msgid ""
"For the `store` and `erase` actions, no response is required (Git ignores it "
"anyway).\n"
"For the `get` action, however, Git is very interested in what the helper has "
"to say.\n"
"If the helper doesn't know anything useful, it can simply exit with no "
"output, but if it does know, it should augment the provided information with "
"the information it has stored.\n"
"The output is treated like a series of assignment statements; anything "
"provided will replace what Git already knows.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:118
#, no-wrap
msgid ""
"Here's the same example from above, but skipping git-credential and going "
"straight for git-credential-store:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:129
#, no-wrap
msgid ""
"$ git credential-store --file ~/git.store store <1>\n"
"protocol=https\n"
"host=mygithost\n"
"username=bob\n"
"password=s3cre7\n"
"$ git credential-store --file ~/git.store get <2>\n"
"protocol=https\n"
"host=mygithost\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:132
#, no-wrap
msgid ""
"username=bob <3>\n"
"password=s3cre7\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:138
#, no-wrap
msgid ""
"<1> Here we tell `git-credential-store` to save some credentials: the "
"username \"`bob`\" and the password \"`s3cre7`\" are to be used when "
"`https://mygithost` is accessed.\n"
"<2> Now we'll retrieve those credentials.\n"
"    We provide the parts of the connection we already know "
"(`https://mygithost`), and an empty line.\n"
"<3> `git-credential-store` replies with the username and password we stored "
"above.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:140
#, no-wrap
msgid "Here's what the `~/git.store` file looks like:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:144
#, no-wrap
msgid ""
"https://bob:s3cre7@mygithost\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:148
#, no-wrap
msgid ""
"It's just a series of lines, each of which contains a credential-decorated "
"URL.\n"
"The `osxkeychain` and `wincred` helpers use the native format of their "
"backing stores, while `cache` uses its own in-memory format (which no other "
"process can read).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:150
#, no-wrap
msgid "==== A Custom Credential Cache\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:157
#, no-wrap
msgid ""
"Given that `git-credential-store` and friends are separate programs from "
"Git, it's not much of a leap to realize that _any_ program can be a Git "
"credential helper.\n"
"The helpers provided by Git cover many common use cases, but not all.\n"
"For example, let's say your team has some credentials that are shared with "
"the entire team, perhaps for deployment.\n"
"These are stored in a shared directory, but you don't want to copy them to "
"your own credential store, because they change often.\n"
"None of the existing helpers cover this case; let's see what it would take "
"to write our own.\n"
"There are several key features this program needs to have:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:161
#, no-wrap
msgid ""
". The only action we need to pay attention to is `get`; `store` and `erase` "
"are write operations, so we'll just exit cleanly when they're received.\n"
". The file format of the shared-credential file is the same as that used by "
"`git-credential-store`.\n"
". The location of that file is fairly standard, but we should allow the user "
"to pass a custom path just in case.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:164
#, no-wrap
msgid ""
"Once again, we'll write this extension in Ruby, but any language will work "
"so long as Git can execute the finished product.\n"
"Here's the full source code of our new credential helper:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:168
#, no-wrap
msgid ""
"include::../git-credential-read-only[]\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:177
#, no-wrap
msgid ""
"<1> Here we parse the command-line options, allowing the user to specify the "
"input file.\n"
"    The default is `~/.git-credentials`.\n"
"<2> This program only responds if the action is `get` and the backing-store "
"file exists.\n"
"<3> This loop reads from stdin until the first blank line is reached.\n"
"    The inputs are stored in the `known` hash for later reference.\n"
"<4> This loop reads the contents of the storage file, looking for matches.\n"
"    If the protocol, host, and username from `known` match this line, the "
"program prints the results to stdout and exits.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:180
#, no-wrap
msgid ""
"We'll save our helper as `git-credential-read-only`, put it somewhere in our "
"`PATH` and mark it executable.\n"
"Here's what an interactive session looks like:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:187
#, no-wrap
msgid ""
"$ git credential-read-only --file=/mnt/shared/creds get\n"
"protocol=https\n"
"host=mygithost\n"
"username=bob\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:192
#, no-wrap
msgid ""
"protocol=https\n"
"host=mygithost\n"
"username=bob\n"
"password=s3cre7\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:195
#, no-wrap
msgid ""
"Since its name starts with \"`git-`\", we can use the simple syntax for the "
"configuration value:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:199
#, no-wrap
msgid ""
"$ git config --global credential.helper 'read-only --file "
"/mnt/shared/creds'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/credentials.asc:201
#, no-wrap
msgid ""
"As you can see, extending this system is pretty straightforward, and can "
"solve some common problems for you and your team.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:2
#, no-wrap
msgid "=== Debugging with Git\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:5
#, no-wrap
msgid ""
"In addition to being primarily for version control, Git also provides a "
"couple commands to help you debug your source code projects.\n"
"Because Git is designed to handle nearly any type of content, these tools "
"are pretty generic, but they can often help you hunt for a bug or culprit "
"when things go wrong.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:8
#, no-wrap
msgid ""
"[[_file_annotation]]\n"
"==== File Annotation\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:12
#, no-wrap
msgid ""
"If you track down a bug in your code and want to know when it was introduced "
"and why, file annotation is often your best tool.\n"
"It shows you what commit was the last to modify each line of any file.\n"
"So if you see that a method in your code is buggy, you can annotate the file "
"with `git blame` to determine which commit was responsible for the "
"introduction of that line.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:14
#, no-wrap
msgid ""
"The following example uses `git blame` to determine which commit and "
"committer was responsible for lines in the top-level Linux kernel `Makefile` "
"and, further, uses the `-L` option to restrict the output of the annotation "
"to lines 69 through 82 of that file:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:32
#, no-wrap
msgid ""
"$ git blame -L 69,82 Makefile\n"
"b8b0618cf6fab (Cheng Renquan  2009-05-26 16:03:07 +0800 69) ifeq (\"$(origin "
"V)\", \"command line\")\n"
"b8b0618cf6fab (Cheng Renquan  2009-05-26 16:03:07 +0800 70)   KBUILD_VERBOSE "
"= $(V)\n"
"^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 71) endif\n"
"^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 72) ifndef "
"KBUILD_VERBOSE\n"
"^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 73)   KBUILD_VERBOSE "
"= 0\n"
"^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 74) endif\n"
"^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 75)\n"
"066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 76) ifeq "
"($(KBUILD_VERBOSE),1)\n"
"066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 77)   quiet =\n"
"066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 78)   Q =\n"
"066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 79) else\n"
"066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 80)   quiet=quiet_\n"
"066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 81)   Q = @\n"
"066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 82) endif\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:39
#, no-wrap
msgid ""
"Notice that the first field is the partial SHA-1 of the commit that last "
"modified that line.\n"
"The next two fields are values extracted from that commit -- the author name "
"and the authored date of that commit -- so you can easily see who modified "
"that line and when.\n"
"After that come the line number and the content of the file.\n"
"Also note the `^1da177e4c3f4` commit lines, where the `^` prefix designates "
"lines that were introduced in the repository's initial commit and have "
"remained unchanged ever since.\n"
"This is a tad confusing, because now you've seen at least three different "
"ways that Git uses the `^` to modify a commit SHA-1, but that is what it "
"means here.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:46
#, no-wrap
msgid ""
"Another cool thing about Git is that it doesn't track file renames "
"explicitly.\n"
"It records the snapshots and then tries to figure out what was renamed "
"implicitly, after the fact.\n"
"One of the interesting features of this is that you can ask it to figure out "
"all sorts of code movement as well.\n"
"If you pass `-C` to `git blame`, Git analyzes the file you're annotating and "
"tries to figure out where snippets of code within it originally came from if "
"they were copied from elsewhere.\n"
"For example, say you are refactoring a file named `GITServerHandler.m` into "
"multiple files, one of which is `GITPackUpload.m`.\n"
"By blaming `GITPackUpload.m` with the `-C` option, you can see where "
"sections of the code originally came from:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:63
#, no-wrap
msgid ""
"$ git blame -C -L 141,153 GITPackUpload.m\n"
"f344f58d GITServerHandler.m (Scott 2009-01-04 141)\n"
"f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) "
"gatherObjectShasFromC\n"
"f344f58d GITServerHandler.m (Scott 2009-01-04 143) {\n"
"70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@\"GATHER "
"COMMI\n"
"ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)\n"
"ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString "
"*parentSha;\n"
"ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit "
"= [g\n"
"ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)\n"
"ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@\"GATHER "
"COMMI\n"
"ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)\n"
"56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {\n"
"56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict "
"setOb\n"
"56ef2caf GITServerHandler.m (Scott 2009-01-05 153)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:68
#, no-wrap
msgid ""
"This is really useful.\n"
"Normally, you get as the original commit the commit where you copied the "
"code over, because that is the first time you touched those lines in this "
"file.\n"
"Git tells you the original commit where you wrote those lines, even if it "
"was in another file.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:71
#, no-wrap
msgid ""
"[[_binary_search]]\n"
"==== Binary Search\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:75
#, no-wrap
msgid ""
"Annotating a file helps if you know where the issue is to begin with.\n"
"If you don't know what is breaking, and there have been dozens or hundreds "
"of commits since the last state where you know the code worked, you'll "
"likely turn to `git bisect` for help.\n"
"The `bisect` command does a binary search through your commit history to "
"help you identify as quickly as possible which commit introduced an issue.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:81
#, no-wrap
msgid ""
"Let's say you just pushed out a release of your code to a production "
"environment, you're getting bug reports about something that wasn't "
"happening in your development environment, and you can't imagine why the "
"code is doing that.\n"
"You go back to your code, and it turns out you can reproduce the issue, but "
"you can't figure out what is going wrong.\n"
"You can _bisect_ the code to find out.\n"
"First you run `git bisect start` to get things going, and then you use `git "
"bisect bad` to tell the system that the current commit you're on is "
"broken.\n"
"Then, you must tell bisect when the last known good state was, using `git "
"bisect good <good_commit>`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:89
#, no-wrap
msgid ""
"$ git bisect start\n"
"$ git bisect bad\n"
"$ git bisect good v1.0\n"
"Bisecting: 6 revisions left to test after this\n"
"[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] Error handling on repo\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:95
#, no-wrap
msgid ""
"Git figured out that about 12 commits came between the commit you marked as "
"the last good commit (v1.0) and the current bad version, and it checked out "
"the middle one for you.\n"
"At this point, you can run your test to see if the issue exists as of this "
"commit.\n"
"If it does, then it was introduced sometime before this middle commit; if it "
"doesn't, then the problem was introduced sometime after the middle commit.\n"
"It turns out there is no issue here, and you tell Git that by typing `git "
"bisect good` and continue your journey:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:101
#, no-wrap
msgid ""
"$ git bisect good\n"
"Bisecting: 3 revisions left to test after this\n"
"[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] Secure this thing\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:105
#, no-wrap
msgid ""
"Now you're on another commit, halfway between the one you just tested and "
"your bad commit.\n"
"You run your test again and find that this commit is broken, so you tell Git "
"that with `git bisect bad`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:111
#, no-wrap
msgid ""
"$ git bisect bad\n"
"Bisecting: 1 revisions left to test after this\n"
"[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] Drop exceptions table\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:115
#, no-wrap
msgid ""
"This commit is fine, and now Git has all the information it needs to "
"determine where the issue was introduced.\n"
"It tells you the SHA-1 of the first bad commit and show some of the commit "
"information and which files were modified in that commit so you can figure "
"out what happened that may have introduced this bug:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:123
#, no-wrap
msgid ""
"$ git bisect good\n"
"b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit\n"
"commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04\n"
"Author: PJ Hyett <pjhyett@example.com>\n"
"Date:   Tue Jan 27 14:48:32 2009 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:125
#, no-wrap
msgid "    Secure this thing\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:128
#, no-wrap
msgid ""
":040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730\n"
"f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:131
#, no-wrap
msgid ""
"When you're finished, you should run `git bisect reset` to reset your HEAD "
"to where you were before you started, or you'll end up in a weird state:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:135
#, no-wrap
msgid ""
"$ git bisect reset\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:141
#, no-wrap
msgid ""
"This is a powerful tool that can help you check hundreds of commits for an "
"introduced bug in minutes.\n"
"In fact, if you have a script that will exit 0 if the project is good or "
"non-0 if the project is bad, you can fully automate `git bisect`.\n"
"First, you again tell it the scope of the bisect by providing the known bad "
"and good commits.\n"
"You can do this by listing them with the `bisect start` command if you want, "
"listing the known bad commit first and the known good commit second:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:146
#, no-wrap
msgid ""
"$ git bisect start HEAD v1.0\n"
"$ git bisect run test-error.sh\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/debugging.asc:149
#, no-wrap
msgid ""
"Doing so automatically runs `test-error.sh` on each checked-out commit until "
"Git finds the first broken commit.\n"
"You can also run something like `make` or `make tests` or whatever you have "
"that runs automated tests for you.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:3
#, no-wrap
msgid ""
"[[_interactive_staging]]\n"
"=== Interactive Staging\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:7
#, no-wrap
msgid ""
"In this section, you'll look at a few interactive Git commands that can help "
"you craft your commits to include only certain combinations and parts of "
"files.\n"
"These tools are helpful if you modify a number of files extensively, then "
"decide that you want those changes to be partitioned into several focused "
"commits rather than one big messy commit.\n"
"This way, you can make sure your commits are logically separate changesets "
"and can be reviewed easily by the developers working with you.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:9
#, no-wrap
msgid ""
"If you run `git add` with the `-i` or `--interactive` option, Git enters an "
"interactive shell mode, displaying something like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:17
#, no-wrap
msgid ""
"$ git add -i\n"
"           staged     unstaged path\n"
"  1:    unchanged        +0/-1 TODO\n"
"  2:    unchanged        +1/-1 index.html\n"
"  3:    unchanged        +5/-1 lib/simplegit.rb\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:22
#, no-wrap
msgid ""
"*** Commands ***\n"
"  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n"
"  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\n"
"What now>\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:26
#, no-wrap
msgid ""
"You can see that this command shows you a much different view of your "
"staging area than you're probably used to -- basically, the same information "
"you get with `git status` but a bit more succinct and informative.\n"
"It lists the changes you've staged on the left and unstaged changes on the "
"right.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:28
#, no-wrap
msgid ""
"After this comes a \"`Commands`\" section, which allows you to do a number "
"of things like staging and unstaging files, staging parts of files, adding "
"untracked files, and displaying diffs of what has been staged.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:30
#, no-wrap
msgid "==== Staging and Unstaging Files\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:32
#, no-wrap
msgid ""
"If you type `u` or `2` (for update) at the `What now>` prompt, you're "
"prompted for which files you want to stage:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:41
#, no-wrap
msgid ""
"What now> u\n"
"           staged     unstaged path\n"
"  1:    unchanged        +0/-1 TODO\n"
"  2:    unchanged        +1/-1 index.html\n"
"  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"Update>>\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:44
#, no-wrap
msgid "To stage the `TODO` and `index.html` files, you can type the numbers:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:53
#, no-wrap
msgid ""
"Update>> 1,2\n"
"           staged     unstaged path\n"
"* 1:    unchanged        +0/-1 TODO\n"
"* 2:    unchanged        +1/-1 index.html\n"
"  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"Update>>\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:57
#, no-wrap
msgid ""
"The `*` next to each file means the file is selected to be staged.\n"
"If you press Enter after typing nothing at the `Update>>` prompt, Git takes "
"anything selected and stages it for you:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:62
#, no-wrap
msgid ""
"Update>>\n"
"updated 2 paths\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:71
#, no-wrap
msgid ""
"*** Commands ***\n"
"  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n"
"  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\n"
"What now> s\n"
"           staged     unstaged path\n"
"  1:        +0/-1      nothing TODO\n"
"  2:        +1/-1      nothing index.html\n"
"  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:75
#, no-wrap
msgid ""
"Now you can see that the `TODO` and `index.html` files are staged and the "
"`simplegit.rb` file is still unstaged.\n"
"If you want to unstage the `TODO` file at this point, you use the `r` or `3` "
"(for revert) option:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:93
#, no-wrap
msgid ""
"*** Commands ***\n"
"  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n"
"  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\n"
"What now> r\n"
"           staged     unstaged path\n"
"  1:        +0/-1      nothing TODO\n"
"  2:        +1/-1      nothing index.html\n"
"  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"Revert>> 1\n"
"           staged     unstaged path\n"
"* 1:        +0/-1      nothing TODO\n"
"  2:        +1/-1      nothing index.html\n"
"  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"Revert>> [enter]\n"
"reverted one path\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:96
#, no-wrap
msgid ""
"Looking at your Git status again, you can see that you've unstaged the "
"`TODO` file:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:107
#, no-wrap
msgid ""
"*** Commands ***\n"
"  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n"
"  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\n"
"What now> s\n"
"           staged     unstaged path\n"
"  1:    unchanged        +0/-1 TODO\n"
"  2:        +1/-1      nothing index.html\n"
"  3:    unchanged        +5/-1 lib/simplegit.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:112
#, no-wrap
msgid ""
"To see the diff of what you've staged, you can use the `d` or `6` (for diff) "
"command.\n"
"It shows you a list of your staged files, and you can select the ones for "
"which you would like to see the staged diff.\n"
"This is much like specifying `git diff --cached` on the command line:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:127
#, no-wrap
msgid ""
"*** Commands ***\n"
"  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n"
"  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\n"
"What now> d\n"
"           staged     unstaged path\n"
"  1:        +1/-1      nothing index.html\n"
"Review diff>> 1\n"
"diff --git a/index.html b/index.html\n"
"index 4d07108..4335f49 100644\n"
"--- a/index.html\n"
"+++ b/index.html\n"
"@@ -16,7 +16,7 @@ Date Finder\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:129
#, no-wrap
msgid " <p id=\"out\">...</p>\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:132
#, no-wrap
msgid ""
"-<div id=\"footer\">contact : support@github.com</div>\n"
"+<div id=\"footer\">contact : email.support@github.com</div>\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:134
#, no-wrap
msgid ""
" <script type=\"text/javascript\">\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:137
#, no-wrap
msgid ""
"With these basic commands, you can use the interactive add mode to deal with "
"your staging area a little more easily.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:139
#, no-wrap
msgid "==== Staging Patches\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:144
#, no-wrap
msgid ""
"It's also possible for Git to stage certain _parts_ of files and not the "
"rest.\n"
"For example, if you make two changes to your `simplegit.rb` file and want to "
"stage one of them and not the other, doing so is very easy in Git.\n"
"From the same interactive prompt explained in the previous section, type `p` "
"or `5` (for patch).\n"
"Git will ask you which files you would like to partially stage; then, for "
"each section of the selected files, it will display hunks of the file diff "
"and ask if you would like to stage them, one by one:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:153
#, no-wrap
msgid ""
"diff --git a/lib/simplegit.rb b/lib/simplegit.rb\n"
"index dd5ecc4..57399e0 100644\n"
"--- a/lib/simplegit.rb\n"
"+++ b/lib/simplegit.rb\n"
"@@ -22,7 +22,7 @@ class SimpleGit\n"
"   end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:158
#, no-wrap
msgid ""
"   def log(treeish = 'master')\n"
"-    command(\"git log -n 25 #{treeish}\")\n"
"+    command(\"git log -n 30 #{treeish}\")\n"
"   end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:161
#, no-wrap
msgid ""
"   def blame(path)\n"
"Stage this hunk [y,n,a,d,/,j,J,g,e,?]?\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:165
#, no-wrap
msgid ""
"You have a lot of options at this point.\n"
"Typing `?` shows a list of what you can do:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:182
#, no-wrap
msgid ""
"Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?\n"
"y - stage this hunk\n"
"n - do not stage this hunk\n"
"a - stage this and all the remaining hunks in the file\n"
"d - do not stage this hunk nor any of the remaining hunks in the file\n"
"g - select a hunk to go to\n"
"/ - search for a hunk matching the given regex\n"
"j - leave this hunk undecided, see next undecided hunk\n"
"J - leave this hunk undecided, see next hunk\n"
"k - leave this hunk undecided, see previous undecided hunk\n"
"K - leave this hunk undecided, see previous hunk\n"
"s - split the current hunk into smaller hunks\n"
"e - manually edit the current hunk\n"
"? - print help\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:186
#, no-wrap
msgid ""
"Generally, you'll type `y` or `n` if you want to stage each hunk, but "
"staging all of them in certain files or skipping a hunk decision until later "
"can be helpful too.\n"
"If you stage one part of the file and leave another part unstaged, your "
"status output will look like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:194
#, no-wrap
msgid ""
"What now> 1\n"
"           staged     unstaged path\n"
"  1:    unchanged        +0/-1 TODO\n"
"  2:        +1/-1      nothing index.html\n"
"  3:        +1/-1        +4/-0 lib/simplegit.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:200
#, no-wrap
msgid ""
"The status of the `simplegit.rb` file is interesting.\n"
"It shows you that a couple of lines are staged and a couple are unstaged.\n"
"You've partially staged this file.\n"
"At this point, you can exit the interactive adding script and run `git "
"commit` to commit the partially staged files.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:202
#, no-wrap
msgid ""
"You also don't need to be in interactive add mode to do the partial-file "
"staging -- you can start the same script by using `git add -p` or `git add "
"--patch` on the command line.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/interactive-staging.asc:204
#, no-wrap
msgid ""
"Furthermore, you can use patch mode for partially resetting files with the "
"`git reset --patch` command, for checking out parts of files with the `git "
"checkout --patch` command and for stashing parts of files with the `git "
"stash save --patch` command.\n"
"We'll go into more details on each of these as we get to more advanced "
"usages of these commands.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:3
#, no-wrap
msgid ""
"[[_replace]]\n"
"=== Replace\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:5
#, no-wrap
msgid ""
"As we've emphasized before, the objects in Git's object database are "
"unchangeable, but Git does provide an interesting way to _pretend_ to "
"replace objects in its database with other objects.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:8
#, no-wrap
msgid ""
"The `replace` command lets you specify an object in Git and say \"every time "
"you refer to _this_ object, pretend it's a _different_ object\".\n"
"This is most commonly useful for replacing one commit in your history with "
"another one without having to rebuild the entire history with, say, `git "
"filter-branch`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:12
#, no-wrap
msgid ""
"For example, let's say you have a huge code history and want to split your "
"repository into one short history for new developers and one much longer and "
"larger history for people interested in data mining.\n"
"You can graft one history onto the other by \"replacing\" the earliest "
"commit in the new line with the latest commit on the older one.\n"
"This is nice because it means that you don't actually have to rewrite every "
"commit in the new history, as you would normally have to do to join them "
"together (because the parentage affects the SHA-1s).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:15
#, no-wrap
msgid ""
"Let's try this out.\n"
"Let's take an existing repository, split it into two repositories, one "
"recent and one historical, and then we'll see how we can recombine them "
"without modifying the recent repositories SHA-1 values via `replace`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:17
#, no-wrap
msgid "We'll use a simple repository with five simple commits:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:26
#, no-wrap
msgid ""
"$ git log --oneline\n"
"ef989d8 Fifth commit\n"
"c6e1e95 Fourth commit\n"
"9c68fdc Third commit\n"
"945704c Second commit\n"
"c1822cf First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:31
#, no-wrap
msgid ""
"We want to break this up into two lines of history.\n"
"One line goes from commit one to commit four - that will be the historical "
"one.\n"
"The second line will just be commits four and five - that will be the recent "
"history.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:33
#, no-wrap
msgid "image::images/replace1.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:35
#, no-wrap
msgid ""
"Well, creating the historical history is easy, we can just put a branch in "
"the history and then push that branch to the `master` branch of a new remote "
"repository.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:45
#, no-wrap
msgid ""
"$ git branch history c6e1e95\n"
"$ git log --oneline --decorate\n"
"ef989d8 (HEAD, master) Fifth commit\n"
"c6e1e95 (history) Fourth commit\n"
"9c68fdc Third commit\n"
"945704c Second commit\n"
"c1822cf First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:48
#, no-wrap
msgid "image::images/replace2.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:50
#, no-wrap
msgid ""
"Now we can push the new `history` branch to the `master` branch of our new "
"repository:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:63
#, no-wrap
msgid ""
"$ git remote add project-history "
"https://github.com/schacon/project-history\n"
"$ git push project-history history:master\n"
"Counting objects: 12, done.\n"
"Delta compression using up to 2 threads.\n"
"Compressing objects: 100% (4/4), done.\n"
"Writing objects: 100% (12/12), 907 bytes, done.\n"
"Total 12 (delta 0), reused 0 (delta 0)\n"
"Unpacking objects: 100% (12/12), done.\n"
"To git@github.com:schacon/project-history.git\n"
" * [new branch]      history -> master\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:68
#, no-wrap
msgid ""
"OK, so our history is published.\n"
"Now the harder part is truncating our recent history down so it's smaller.\n"
"We need an overlap so we can replace a commit in one with an equivalent "
"commit in the other, so we're going to truncate this to just commits four "
"and five (so commit four overlaps).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:77
#, no-wrap
msgid ""
"$ git log --oneline --decorate\n"
"ef989d8 (HEAD, master) Fifth commit\n"
"c6e1e95 (history) Fourth commit\n"
"9c68fdc Third commit\n"
"945704c Second commit\n"
"c1822cf First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:81
#, no-wrap
msgid ""
"It's useful in this case to create a base commit that has instructions on "
"how to expand the history, so other developers know what to do if they hit "
"the first commit in the truncated history and need more.\n"
"So, what we're going to do is create an initial commit object as our base "
"point with instructions, then rebase the remaining commits (four and five) "
"on top of it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:85
#, no-wrap
msgid ""
"To do that, we need to choose a point to split at, which for us is the third "
"commit, which is `9c68fdc` in SHA-speak.\n"
"So, our base commit will be based off of that tree.\n"
"We can create our base commit using the `commit-tree` command, which just "
"takes a tree and will give us a brand new, parentless commit object SHA-1 "
"back.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:90
#, no-wrap
msgid ""
"$ echo 'Get history from blah blah blah' | git commit-tree 9c68fdc^{tree}\n"
"622e88e9cbfbacfb75b5279245b9fb38dfea10cf\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:93
#: book/07-git-tools/sections/submodules.asc:73
#, no-wrap
msgid ""
"[NOTE]\n"
"=====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:98
#, no-wrap
msgid ""
"The `commit-tree` command is one of a set of commands that are commonly "
"referred to as 'plumbing' commands.\n"
"These are commands that are not generally meant to be used directly, but "
"instead are used by *other* Git commands to do smaller jobs.\n"
"On occasions when we're doing weirder things like this, they allow us to do "
"really low-level things but are not meant for daily use.\n"
"You can read more about plumbing commands in "
"<<ch10-git-internals#_plumbing_porcelain>>.\n"
"=====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:101
#, no-wrap
msgid "image::images/replace3.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:104
#, no-wrap
msgid ""
"OK, so now that we have a base commit, we can rebase the rest of our history "
"on top of that with `git rebase --onto`.\n"
"The `--onto` argument will be the SHA-1 we just got back from `commit-tree` "
"and the rebase point will be the third commit (the parent of the first "
"commit we want to keep, `9c68fdc`):\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:111
#, no-wrap
msgid ""
"$ git rebase --onto 622e88 9c68fdc\n"
"First, rewinding head to replay your work on top of it...\n"
"Applying: fourth commit\n"
"Applying: fifth commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:114
#, no-wrap
msgid "image::images/replace4.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:117
#, no-wrap
msgid ""
"OK, so now we've re-written our recent history on top of a throw away base "
"commit that now has instructions in it on how to reconstitute the entire "
"history if we wanted to.\n"
"We can push that new history to a new project and now when people clone that "
"repository, they will only see the most recent two commits and then a base "
"commit with instructions.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:120
#, no-wrap
msgid ""
"Let's now switch roles to someone cloning the project for the first time who "
"wants the entire history.\n"
"To get the history data after cloning this truncated repository, one would "
"have to add a second remote for the historical repository and fetch:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:125
#, no-wrap
msgid ""
"$ git clone https://github.com/schacon/project\n"
"$ cd project\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:130
#: book/07-git-tools/sections/replace.asc:145
#, no-wrap
msgid ""
"$ git log --oneline master\n"
"e146b5f Fifth commit\n"
"81a708d Fourth commit\n"
"622e88e Get history from blah blah blah\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:135
#, no-wrap
msgid ""
"$ git remote add project-history "
"https://github.com/schacon/project-history\n"
"$ git fetch project-history\n"
"From https://github.com/schacon/project-history\n"
" * [new branch]      master     -> project-history/master\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:138
#, no-wrap
msgid ""
"Now the collaborator would have their recent commits in the `master` branch "
"and the historical commits in the `project-history/master` branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:151
#, no-wrap
msgid ""
"$ git log --oneline project-history/master\n"
"c6e1e95 Fourth commit\n"
"9c68fdc Third commit\n"
"945704c Second commit\n"
"c1822cf First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:155
#, no-wrap
msgid ""
"To combine them, you can simply call `git replace` with the commit you want "
"to replace and then the commit you want to replace it with.\n"
"So we want to replace the \"fourth\" commit in the `master` branch with the "
"\"fourth\" commit in the `project-history/master` branch:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:159
#, no-wrap
msgid ""
"$ git replace 81a708d c6e1e95\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:162
#, no-wrap
msgid ""
"Now, if you look at the history of the `master` branch, it appears to look "
"like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:171
#, no-wrap
msgid ""
"$ git log --oneline master\n"
"e146b5f Fifth commit\n"
"81a708d Fourth commit\n"
"9c68fdc Third commit\n"
"945704c Second commit\n"
"c1822cf First commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:174
#, no-wrap
msgid ""
"Cool, right?  Without having to change all the SHA-1s upstream, we were able "
"to replace one commit in our history with an entirely different commit and "
"all the normal tools (`bisect`, `blame`, etc) will work how we would expect "
"them to.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:176
#, no-wrap
msgid "image::images/replace5.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:179
#, no-wrap
msgid ""
"Interestingly, it still shows `81a708d` as the SHA-1, even though it's "
"actually using the `c6e1e95` commit data that we replaced it with.\n"
"Even if you run a command like `cat-file`, it will show you the replaced "
"data:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:187
#, no-wrap
msgid ""
"$ git cat-file -p 81a708d\n"
"tree 7bc544cf438903b65ca9104a1e30345eee6c083d\n"
"parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252\n"
"author Scott Chacon <schacon@gmail.com> 1268712581 -0700\n"
"committer Scott Chacon <schacon@gmail.com> 1268712581 -0700\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:189
#, no-wrap
msgid ""
"fourth commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:192
#, no-wrap
msgid ""
"Remember that the actual parent of `81a708d` was our placeholder commit "
"(`622e88e`), not `9c68fdce` as it states here.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:194
#, no-wrap
msgid "Another interesting thing is that this data is kept in our references:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:203
#, no-wrap
msgid ""
"$ git for-each-ref\n"
"e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit\trefs/heads/master\n"
"c6e1e95051d41771a649f3145423f8809d1a74d4 "
"commit\trefs/remotes/history/master\n"
"e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit\trefs/remotes/origin/HEAD\n"
"e146b5f14e79d4935160c0e83fb9ebe526b8da0d "
"commit\trefs/remotes/origin/master\n"
"c6e1e95051d41771a649f3145423f8809d1a74d4 "
"commit\trefs/replace/81a708dd0e167a3f691541c7a6463343bc457040\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/replace.asc:206
#, no-wrap
msgid ""
"This means that it's easy to share our replacement with others, because we "
"can push this to our server and other people can easily download it.\n"
"This is not that helpful in the history grafting scenario we've gone over "
"here (since everyone would be downloading both histories anyhow, so why "
"separate them?) but it can be useful in other circumstances.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:3
#, no-wrap
msgid ""
"[[ref_rerere]]\n"
"=== Rerere\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:6
#, no-wrap
msgid ""
"The `git rerere` functionality is a bit of a hidden feature.\n"
"The name stands for \"`reuse recorded resolution`\" and, as the name "
"implies, it allows you to ask Git to remember how you've resolved a hunk "
"conflict so that the next time it sees the same conflict, Git can resolve it "
"for you automatically.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:11
#, no-wrap
msgid ""
"There are a number of scenarios in which this functionality might be really "
"handy.\n"
"One of the examples that is mentioned in the documentation is when you want "
"to make sure a long-lived topic branch will ultimately merge cleanly, but "
"you don't want to have a bunch of intermediate merge commits cluttering up "
"your commit history.\n"
"With `rerere` enabled, you can attempt the occasional merge, resolve the "
"conflicts, then back out of the merge.\n"
"If you do this continuously, then the final merge should be easy because "
"`rerere` can just do everything for you automatically.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:14
#, no-wrap
msgid ""
"This same tactic can be used if you want to keep a branch rebased so you "
"don't have to deal with the same rebasing conflicts each time you do it.\n"
"Or if you want to take a branch that you merged and fixed a bunch of "
"conflicts and then decide to rebase it instead -- you likely won't have to "
"do all the same conflicts again.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:17
#, no-wrap
msgid ""
"Another application of `rerere` is where you merge a bunch of evolving topic "
"branches together into a testable head occasionally, as the Git project "
"itself often does.\n"
"If the tests fail, you can rewind the merges and re-do them without the "
"topic branch that made the tests fail without having to re-resolve the "
"conflicts again.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:19
#, no-wrap
msgid ""
"To enable `rerere` functionality, you simply have to run this config "
"setting:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:23
#, no-wrap
msgid ""
"$ git config --global rerere.enabled true\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:26
#, no-wrap
msgid ""
"You can also turn it on by creating the `.git/rr-cache` directory in a "
"specific repository, but the config setting is clearer and enables that "
"feature globally for you.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:29
#, no-wrap
msgid ""
"Now let's see a simple example, similar to our previous one.\n"
"Let's say we have a file named `hello.rb` that looks like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:37
#, no-wrap
msgid ""
"def hello\n"
"  puts 'hello world'\n"
"end\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:40
#, no-wrap
msgid ""
"In one branch we change the word \"`hello`\" to \"`hola`\", then in another "
"branch we change the \"`world`\" to \"`mundo`\", just like before.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:42
#, no-wrap
msgid "image::images/rerere1.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:44
#, no-wrap
msgid "When we merge the two branches together, we'll get a merge conflict:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:52
#, no-wrap
msgid ""
"$ git merge i18n-world\n"
"Auto-merging hello.rb\n"
"CONFLICT (content): Merge conflict in hello.rb\n"
"Recorded preimage for 'hello.rb'\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:58
#, no-wrap
msgid ""
"You should notice the new line `Recorded preimage for FILE` in there.\n"
"Otherwise it should look exactly like a normal merge conflict.\n"
"At this point, `rerere` can tell us a few things.\n"
"Normally, you might run `git status` at this point to see what all "
"conflicted:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:69
#, no-wrap
msgid ""
"$ git status\n"
"# On branch master\n"
"# Unmerged paths:\n"
"#   (use \"git reset HEAD <file>...\" to unstage)\n"
"#   (use \"git add <file>...\" to mark resolution)\n"
"#\n"
"#\tboth modified:      hello.rb\n"
"#\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:72
#, no-wrap
msgid ""
"However, `git rerere` will also tell you what it has recorded the pre-merge "
"state for with `git rerere status`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:77
#, no-wrap
msgid ""
"$ git rerere status\n"
"hello.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:80
#, no-wrap
msgid ""
"And `git rerere diff` will show the current state of the resolution -- what "
"you started with to resolve and what you've resolved it to.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:88
#, no-wrap
msgid ""
"$ git rerere diff\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@ -1,11 +1,11 @@\n"
" #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:100
#, no-wrap
msgid ""
" def hello\n"
"-<<<<<<<\n"
"-  puts 'hello mundo'\n"
"-=======\n"
"+<<<<<<< HEAD\n"
"   puts 'hola world'\n"
"->>>>>>>\n"
"+=======\n"
"+  puts 'hello mundo'\n"
"+>>>>>>> i18n-world\n"
" end\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:103
#, no-wrap
msgid ""
"Also (and this isn't really related to `rerere`), you can use `git ls-files "
"-u` to see the conflicted files and the before, left and right versions:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:110
#, no-wrap
msgid ""
"$ git ls-files -u\n"
"100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1\thello.rb\n"
"100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2\thello.rb\n"
"100644 54336ba847c3758ab604876419607e9443848474 3\thello.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:113
#, no-wrap
msgid ""
"Now you can resolve it to just be `puts 'hola mundo'` and you can run `git "
"rerere diff` again to see what rerere will remember:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:121
#, no-wrap
msgid ""
"$ git rerere diff\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@ -1,11 +1,7 @@\n"
" #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:130
#, no-wrap
msgid ""
" def hello\n"
"-<<<<<<<\n"
"-  puts 'hello mundo'\n"
"-=======\n"
"-  puts 'hola world'\n"
"->>>>>>>\n"
"+  puts 'hola mundo'\n"
" end\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:133
#, no-wrap
msgid ""
"So that basically says, when Git sees a hunk conflict in a `hello.rb` file "
"that has \"`hello mundo`\" on one side and \"`hola world`\" on the other, it "
"will resolve it to \"`hola mundo`\".\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:135
#, no-wrap
msgid "Now we can mark it as resolved and commit it:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:142
#, no-wrap
msgid ""
"$ git add hello.rb\n"
"$ git commit\n"
"Recorded resolution for 'hello.rb'.\n"
"[master 68e16e5] Merge branch 'i18n'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:145
#, no-wrap
msgid "You can see that it \"Recorded resolution for FILE\".\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:147
#, no-wrap
msgid "image::images/rerere2.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:150
#, no-wrap
msgid ""
"Now, let's undo that merge and then rebase it on top of our `master` branch "
"instead.\n"
"We can move our branch back by using `git reset` as we saw in "
"<<ch07-git-tools#_git_reset>>.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:155
#, no-wrap
msgid ""
"$ git reset --hard HEAD^\n"
"HEAD is now at ad63f15 i18n the hello\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:159
#, no-wrap
msgid ""
"Our merge is undone.\n"
"Now let's rebase the topic branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:164
#, no-wrap
msgid ""
"$ git checkout i18n-world\n"
"Switched to branch 'i18n-world'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:175
#, no-wrap
msgid ""
"$ git rebase master\n"
"First, rewinding head to replay your work on top of it...\n"
"Applying: i18n one word\n"
"Using index info to reconstruct a base tree...\n"
"Falling back to patching base and 3-way merge...\n"
"Auto-merging hello.rb\n"
"CONFLICT (content): Merge conflict in hello.rb\n"
"Resolved 'hello.rb' using previous resolution.\n"
"Failed to merge in the changes.\n"
"Patch failed at 0001 i18n one word\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:179
#, no-wrap
msgid ""
"Now, we got the same merge conflict like we expected, but take a look at the "
"`Resolved FILE using previous resolution` line.\n"
"If we look at the file, we'll see that it's already been resolved, there are "
"no merge conflict markers in it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:187
#: book/07-git-tools/sections/rerere.asc:240
#, no-wrap
msgid ""
"def hello\n"
"  puts 'hola mundo'\n"
"end\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:190
#, no-wrap
msgid "Also, `git diff` will show you how it was automatically re-resolved:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:200
#, no-wrap
msgid ""
"$ git diff\n"
"diff --cc hello.rb\n"
"index a440db6,54336ba..0000000\n"
"--- a/hello.rb\n"
"+++ b/hello.rb\n"
"@@@ -1,7 -1,7 +1,7 @@@\n"
"  #! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:206
#, no-wrap
msgid ""
"  def hello\n"
"-   puts 'hola world'\n"
" -  puts 'hello mundo'\n"
"++  puts 'hola mundo'\n"
"  end\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:209
#, no-wrap
msgid "image::images/rerere3.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:211
#, no-wrap
msgid "You can also recreate the conflicted file state with `git checkout`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:217
#, no-wrap
msgid ""
"$ git checkout --conflict=merge hello.rb\n"
"$ cat hello.rb\n"
"#! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:221
#, no-wrap
msgid ""
"def hello\n"
"<<<<<<< ours\n"
"  puts 'hola world'\n"
"=======\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:225
#, no-wrap
msgid ""
"  puts 'hello mundo'\n"
">>>>>>> theirs\n"
"end\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:229
#, no-wrap
msgid ""
"We saw an example of this in <<ch07-git-tools#_advanced_merging>>.\n"
"For now though, let's re-resolve it by just running `git rerere` again:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:236
#, no-wrap
msgid ""
"$ git rerere\n"
"Resolved 'hello.rb' using previous resolution.\n"
"$ cat hello.rb\n"
"#! /usr/bin/env ruby\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:244
#, no-wrap
msgid ""
"We have re-resolved the file automatically using the `rerere` cached "
"resolution.\n"
"You can now add and continue the rebase to complete it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:250
#, no-wrap
msgid ""
"$ git add hello.rb\n"
"$ git rebase --continue\n"
"Applying: i18n one word\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rerere.asc:252
#, no-wrap
msgid ""
"So, if you do a lot of re-merges, or want to keep a topic branch up to date "
"with your `master` branch without a ton of merges, or you rebase often, you "
"can turn on `rerere` to help your life out a bit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:3
#, no-wrap
msgid ""
"[[_git_reset]]\n"
"=== Reset Demystified\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:8
#, no-wrap
msgid ""
"Before moving on to more specialized tools, let's talk about the Git `reset` "
"and `checkout` commands.\n"
"These commands are two of the most confusing parts of Git when you first "
"encounter them.\n"
"They do so many things that it seems hopeless to actually understand them "
"and employ them properly.\n"
"For this, we recommend a simple metaphor.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:10
#, no-wrap
msgid "==== The Three Trees\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:14
#, no-wrap
msgid ""
"An easier way to think about `reset` and `checkout` is through the mental "
"frame of Git being a content manager of three different trees.\n"
"By \"`tree`\" here, we really mean \"`collection of files`\", not "
"specifically the data structure.\n"
"There are a few cases where the index doesn't exactly act like a tree, but "
"for our purposes it is easier to think about it this way for now.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:16
#, no-wrap
msgid ""
"Git as a system manages and manipulates three trees in its normal "
"operation:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:24
#, no-wrap
msgid ""
"[cols=\"1,2\",options=\"header\"]\n"
"|================================\n"
"| Tree              | Role\n"
"| HEAD              | Last commit snapshot, next parent\n"
"| Index             | Proposed next commit snapshot\n"
"| Working Directory | Sandbox\n"
"|================================\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:26
#, no-wrap
msgid "===== The HEAD\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:30
#, no-wrap
msgid ""
"HEAD is the pointer to the current branch reference, which is in turn a "
"pointer to the last commit made on that branch.\n"
"That means HEAD will be the parent of the next commit that is created.\n"
"It's generally simplest to think of HEAD as the snapshot of *your last "
"commit on that branch*.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:33
#, no-wrap
msgid ""
"In fact, it's pretty easy to see what that snapshot looks like.\n"
"Here is an example of getting the actual directory listing and SHA-1 "
"checksums for each file in the HEAD snapshot:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:40
#, no-wrap
msgid ""
"$ git cat-file -p HEAD\n"
"tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\n"
"author Scott Chacon  1301511835 -0700\n"
"committer Scott Chacon  1301511835 -0700\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:42
#, no-wrap
msgid "initial commit\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:47
#, no-wrap
msgid ""
"$ git ls-tree -r HEAD\n"
"100644 blob a906cb2a4a904a152...   README\n"
"100644 blob 8f94139338f9404f2...   Rakefile\n"
"040000 tree 99f1a6d12cb4b6f19...   lib\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:50
#, no-wrap
msgid ""
"The Git `cat-file` and `ls-tree` commands are \"`plumbing`\" commands that "
"are used for lower level things and not really used in day-to-day work, but "
"they help us see what's going on here.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:53
#, no-wrap
msgid ""
"[[_the_index]]\n"
"===== The Index\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:56
#, no-wrap
msgid ""
"The _index_ is your *proposed next commit*.\n"
"We've also been referring to this concept as Git's \"`Staging Area`\" as "
"this is what Git looks at when you run `git commit`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:59
#, no-wrap
msgid ""
"Git populates this index with a list of all the file contents that were last "
"checked out into your working directory and what they looked like when they "
"were originally checked out.\n"
"You then replace some of those files with new versions of them, and `git "
"commit` converts that into the tree for a new commit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:66
#, no-wrap
msgid ""
"$ git ls-files -s\n"
"100644 a906cb2a4a904a152e80877d4088654daad0c859 0\tREADME\n"
"100644 8f94139338f9404f26296befa88755fc2598c289 0\tRakefile\n"
"100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:69
#, no-wrap
msgid ""
"Again, here we're using `git ls-files`, which is more of a behind the scenes "
"command that shows you what your index currently looks like.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:71
#, no-wrap
msgid ""
"The index is not technically a tree structure -- it's actually implemented "
"as a flattened manifest -- but for our purposes it's close enough.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:73
#, no-wrap
msgid "===== The Working Directory\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:78
#, no-wrap
msgid ""
"Finally, you have your _working directory_ (also commonly referred to as the "
"\"`working tree`\").\n"
"The other two trees store their content in an efficient but inconvenient "
"manner, inside the `.git` folder.\n"
"The working directory unpacks them into actual files, which makes it much "
"easier for you to edit them.\n"
"Think of the working directory as a *sandbox*, where you can try changes out "
"before committing them to your staging area (index) and then to history.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:87
#, no-wrap
msgid ""
"$ tree\n"
".\n"
"âââ README\n"
"âââ Rakefile\n"
"âââ lib\n"
"    âââ simplegit.rb\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:89
#, no-wrap
msgid ""
"1 directory, 3 files\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:92
#, no-wrap
msgid "==== The Workflow\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:94
#, no-wrap
msgid ""
"Git's typical workflow is to record snapshots of your project in "
"successively better states, by manipulating these three trees.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:96
#, no-wrap
msgid "image::images/reset-workflow.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:100
#, no-wrap
msgid ""
"Let's visualize this process: say you go into a new directory with a single "
"file in it.\n"
"We'll call this *v1* of the file, and we'll indicate it in blue.\n"
"Now we run `git init`, which will create a Git repository with a HEAD "
"reference which points to the unborn `master` branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:102
#, no-wrap
msgid "image::images/reset-ex1.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:104
#, no-wrap
msgid "At this point, only the working directory tree has any content.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:106
#, no-wrap
msgid ""
"Now we want to commit this file, so we use `git add` to take content in the "
"working directory and copy it to the index.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:108
#, no-wrap
msgid "image::images/reset-ex2.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:110
#, no-wrap
msgid ""
"Then we run `git commit`, which takes the contents of the index and saves it "
"as a permanent snapshot, creates a commit object which points to that "
"snapshot, and updates `master` to point to that commit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:112
#, no-wrap
msgid "image::images/reset-ex3.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:114
#, no-wrap
msgid ""
"If we run `git status`, we'll see no changes, because all three trees are "
"the same.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:118
#, no-wrap
msgid ""
"Now we want to make a change to that file and commit it.\n"
"We'll go through the same process; first, we change the file in our working "
"directory.\n"
"Let's call this *v2* of the file, and indicate it in red.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:120
#, no-wrap
msgid "image::images/reset-ex4.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:123
#, no-wrap
msgid ""
"If we run `git status` right now, we'll see the file in red as \"`Changes "
"not staged for commit`\", because that entry differs between the index and "
"the working directory.\n"
"Next we run `git add` on it to stage it into our index.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:125
#, no-wrap
msgid "image::images/reset-ex5.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:128
#, no-wrap
msgid ""
"At this point, if we run `git status`, we will see the file in green under "
"\"`Changes to be committed`\" because the index and HEAD differ -- that is, "
"our proposed next commit is now different from our last commit.\n"
"Finally, we run `git commit` to finalize the commit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:130
#, no-wrap
msgid "image::images/reset-ex6.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:132
#, no-wrap
msgid ""
"Now `git status` will give us no output, because all three trees are the "
"same again.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:135
#, no-wrap
msgid ""
"Switching branches or cloning goes through a similar process.\n"
"When you checkout a branch, it changes *HEAD* to point to the new branch "
"ref, populates your *index* with the snapshot of that commit, then copies "
"the contents of the *index* into your *working directory*.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:137
#, no-wrap
msgid "==== The Role of Reset\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:139
#, no-wrap
msgid "The `reset` command makes more sense when viewed in this context.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:142
#, no-wrap
msgid ""
"For the purposes of these examples, let's say that we've modified `file.txt` "
"again and committed it a third time.\n"
"So now our history looks like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:144
#, no-wrap
msgid "image::images/reset-start.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:148
#, no-wrap
msgid ""
"Let's now walk through exactly what `reset` does when you call it.\n"
"It directly manipulates these three trees in a simple and predictable way.\n"
"It does up to three basic operations.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:150
#, no-wrap
msgid "===== Step 1: Move HEAD\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:154
#, no-wrap
msgid ""
"The first thing `reset` will do is move what HEAD points to.\n"
"This isn't the same as changing HEAD itself (which is what `checkout` does); "
"`reset` moves the branch that HEAD is pointing to.\n"
"This means if HEAD is set to the `master` branch (i.e. you're currently on "
"the `master` branch), running `git reset 9e5e6a4` will start by making "
"`master` point to `9e5e6a4`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:156
#, no-wrap
msgid "image::images/reset-soft.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:159
#, no-wrap
msgid ""
"No matter what form of `reset` with a commit you invoke, this is the first "
"thing it will always try to do.\n"
"With `reset --soft`, it will simply stop there.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:164
#, no-wrap
msgid ""
"Now take a second to look at that diagram and realize what happened: it "
"essentially undid the last `git commit` command.\n"
"When you run `git commit`, Git creates a new commit and moves the branch "
"that HEAD points to up to it.\n"
"When you `reset` back to `HEAD~` (the parent of HEAD), you are moving the "
"branch back to where it was, without changing the index or working "
"directory.\n"
"You could now update the index and run `git commit` again to accomplish what "
"`git commit --amend` would have done (see <<_git_amend>>).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:166
#, no-wrap
msgid "===== Step 2: Updating the Index (--mixed)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:168
#, no-wrap
msgid ""
"Note that if you run `git status` now you'll see in green the difference "
"between the index and what the new HEAD is.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:170
#, no-wrap
msgid ""
"The next thing `reset` will do is to update the index with the contents of "
"whatever snapshot HEAD now points to.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:172
#, no-wrap
msgid "image::images/reset-mixed.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:175
#, no-wrap
msgid ""
"If you specify the `--mixed` option, `reset` will stop at this point.\n"
"This is also the default, so if you specify no option at all (just `git "
"reset HEAD~` in this case), this is where the command will stop.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:178
#, no-wrap
msgid ""
"Now take another second to look at that diagram and realize what happened: "
"it still undid your last `commit`, but also _unstaged_ everything.\n"
"You rolled back to before you ran all your `git add` and `git commit` "
"commands.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:180
#, no-wrap
msgid "===== Step 3: Updating the Working Directory (--hard)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:183
#, no-wrap
msgid ""
"The third thing that `reset` will do is to make the working directory look "
"like the index.\n"
"If you use the `--hard` option, it will continue to this stage.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:185
#, no-wrap
msgid "image::images/reset-hard.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:188
#, no-wrap
msgid ""
"So let's think about what just happened.\n"
"You undid your last commit, the `git add` and `git commit` commands, *and* "
"all the work you did in your working directory.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:192
#, no-wrap
msgid ""
"It's important to note that this flag (`--hard`) is the only way to make the "
"`reset` command dangerous, and one of the very few cases where Git will "
"actually destroy data.\n"
"Any other invocation of `reset` can be pretty easily undone, but the "
"`--hard` option cannot, since it forcibly overwrites files in the working "
"directory.\n"
"In this particular case, we still have the *v3* version of our file in a "
"commit in our Git DB, and we could get it back by looking at our `reflog`, "
"but if we had not committed it, Git still would have overwritten the file "
"and it would be unrecoverable.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:194
#, no-wrap
msgid "===== Recap\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:196
#, no-wrap
msgid ""
"The `reset` command overwrites these three trees in a specific order, "
"stopping when you tell it to:\n"
msgstr ""

#. type: Bullet: '1. '
#: book/07-git-tools/sections/reset.asc:200
#, markdown-text, no-wrap
msgid "Move the branch HEAD points to _(stop here if `--soft`)_.\n"
msgstr ""

#. type: Bullet: '2. '
#: book/07-git-tools/sections/reset.asc:200
#, markdown-text, no-wrap
msgid "Make the index look like HEAD _(stop here unless `--hard`)_.\n"
msgstr ""

#. type: Bullet: '3. '
#: book/07-git-tools/sections/reset.asc:200
#, markdown-text, no-wrap
msgid "Make the working directory look like the index.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:202
#, no-wrap
msgid "==== Reset With a Path\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:207
#, no-wrap
msgid ""
"That covers the behavior of `reset` in its basic form, but you can also "
"provide it with a path to act upon.\n"
"If you specify a path, `reset` will skip step 1, and limit the remainder of "
"its actions to a specific file or set of files.\n"
"This actually sort of makes sense -- HEAD is just a pointer, and you can't "
"point to part of one commit and part of another.\n"
"But the index and working directory _can_ be partially updated, so reset "
"proceeds with steps 2 and 3.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:210
#, no-wrap
msgid ""
"So, assume we run `git reset file.txt`.\n"
"This form (since you did not specify a commit SHA-1 or branch, and you "
"didn't specify `--soft` or `--hard`) is shorthand for `git reset --mixed "
"HEAD file.txt`, which will:\n"
msgstr ""

#. type: Bullet: '1. '
#: book/07-git-tools/sections/reset.asc:213
#, markdown-text, no-wrap
msgid "Move the branch HEAD points to _(skipped)_.\n"
msgstr ""

#. type: Bullet: '2. '
#: book/07-git-tools/sections/reset.asc:213
#, markdown-text, no-wrap
msgid "Make the index look like HEAD _(stop here)_.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:215
#, no-wrap
msgid "So it essentially just copies `file.txt` from HEAD to the index.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:217
#, no-wrap
msgid "image::images/reset-path1.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:220
#, no-wrap
msgid ""
"This has the practical effect of _unstaging_ the file.\n"
"If we look at the diagram for that command and think about what `git add` "
"does, they are exact opposites.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:222
#, no-wrap
msgid "image::images/reset-path2.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:224
#, no-wrap
msgid ""
"This is why the output of the `git status` command suggests that you run "
"this to unstage a file (see <<ch02-git-basics-chapter#_unstaging>> for more "
"on this).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:227
#, no-wrap
msgid ""
"We could just as easily not let Git assume we meant \"`pull the data from "
"HEAD`\" by specifying a specific commit to pull that file version from.\n"
"We would just run something like `git reset eb43bf file.txt`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:229
#, no-wrap
msgid "image::images/reset-path3.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:232
#, no-wrap
msgid ""
"This effectively does the same thing as if we had reverted the content of "
"the file to *v1* in the working directory, ran `git add` on it, then "
"reverted it back to *v3* again (without actually going through all those "
"steps).\n"
"If we run `git commit` now, it will record a change that reverts that file "
"back to *v1*, even though we never actually had it in our working directory "
"again.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:235
#, no-wrap
msgid ""
"It's also interesting to note that like `git add`, the `reset` command will "
"accept a `--patch` option to unstage content on a hunk-by-hunk basis.\n"
"So you can selectively unstage or revert content.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:237
#, no-wrap
msgid "==== Squashing\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:239
#, no-wrap
msgid ""
"Let's look at how to do something interesting with this newfound power -- "
"squashing commits.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:243
#, no-wrap
msgid ""
"Say you have a series of commits with messages like \"`oops.`\", \"`WIP`\" "
"and \"`forgot this file`\".\n"
"You can use `reset` to quickly and easily squash them into a single commit "
"that makes you look really smart.\n"
"<<_squashing>> shows another way to do this, but in this example it's "
"simpler to use `reset`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:246
#, no-wrap
msgid ""
"Let's say you have a project where the first commit has one file, the second "
"commit added a new file and changed the first, and the third commit changed "
"the first file again.\n"
"The second commit was a work in progress and you want to squash it down.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:248
#, no-wrap
msgid "image::images/reset-squash-r1.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:250
#, no-wrap
msgid ""
"You can run `git reset --soft HEAD~2` to move the HEAD branch back to an "
"older commit (the most recent commit you want to keep):\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:252
#, no-wrap
msgid "image::images/reset-squash-r2.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:254
#, no-wrap
msgid "And then simply run `git commit` again:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:256
#, no-wrap
msgid "image::images/reset-squash-r3.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:259
#, no-wrap
msgid ""
"Now you can see that your reachable history, the history you would push, now "
"looks like you had one commit with `file-a.txt` v1, then a second that both "
"modified `file-a.txt` to v3 and added `file-b.txt`.\n"
"The commit with the v2 version of the file is no longer in the history.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:261
#, no-wrap
msgid "==== Check It Out\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:264
#, no-wrap
msgid ""
"Finally, you may wonder what the difference between `checkout` and `reset` "
"is.\n"
"Like `reset`, `checkout` manipulates the three trees, and it is a bit "
"different depending on whether you give the command a file path or not.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:266
#, no-wrap
msgid "===== Without Paths\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:268
#, no-wrap
msgid ""
"Running `git checkout [branch]` is pretty similar to running `git reset "
"--hard [branch]` in that it updates all three trees for you to look like "
"`[branch]`, but there are two important differences.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:272
#, no-wrap
msgid ""
"First, unlike `reset --hard`, `checkout` is working-directory safe; it will "
"check to make sure it's not blowing away files that have changes to them.\n"
"Actually, it's a bit smarter than that -- it tries to do a trivial merge in "
"the working directory, so all of the files you _haven't_ changed will be "
"updated.\n"
"`reset --hard`, on the other hand, will simply replace everything across the "
"board without checking.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:275
#, no-wrap
msgid ""
"The second important difference is how `checkout` updates HEAD.\n"
"Whereas `reset` will move the branch that HEAD points to, `checkout` will "
"move HEAD itself to point to another branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:280
#, no-wrap
msgid ""
"For instance, say we have `master` and `develop` branches which point at "
"different commits, and we're currently on `develop` (so HEAD points to "
"it).\n"
"If we run `git reset master`, `develop` itself will now point to the same "
"commit that `master` does.\n"
"If we instead run `git checkout master`, `develop` does not move, HEAD "
"itself does.\n"
"HEAD will now point to `master`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:283
#, no-wrap
msgid ""
"So, in both cases we're moving HEAD to point to commit A, but _how_ we do so "
"is very different.\n"
"`reset` will move the branch HEAD points to, `checkout` moves HEAD itself.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:285
#, no-wrap
msgid "image::images/reset-checkout.png[]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:287
#, no-wrap
msgid "===== With Paths\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:291
#, no-wrap
msgid ""
"The other way to run `checkout` is with a file path, which, like `reset`, "
"does not move HEAD.\n"
"It is just like `git reset [branch] file` in that it updates the index with "
"that file at that commit, but it also overwrites the file in the working "
"directory.\n"
"It would be exactly like `git reset --hard [branch] file` (if `reset` would "
"let you run that) -- it's not working-directory safe, and it does not move "
"HEAD.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:293
#, no-wrap
msgid ""
"Also, like `git reset` and `git add`, `checkout` will accept a `--patch` "
"option to allow you to selectively revert file contents on a hunk-by-hunk "
"basis.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:295
#, no-wrap
msgid "==== Summary\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:297
#, no-wrap
msgid ""
"Hopefully now you understand and feel more comfortable with the `reset` "
"command, but are probably still a little confused about how exactly it "
"differs from `checkout` and could not possibly remember all the rules of the "
"different invocations.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:301
#, no-wrap
msgid ""
"Here's a cheat-sheet for which commands affect which trees.\n"
"The \"`HEAD`\" column reads \"`REF`\" if that command moves the reference "
"(branch) that HEAD points to, and \"`HEAD`\" if it moves HEAD itself.\n"
"Pay especial attention to the 'WD Safe?' column -- if it says *NO*, take a "
"second to think before running that command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/reset.asc:313
#, no-wrap
msgid ""
"[options=\"header\", cols=\"3,1,1,1,1\"]\n"
"|================================\n"
"| | HEAD | Index | Workdir | WD Safe?\n"
"| *Commit Level* | | | |\n"
"| `reset --soft [commit]` | REF | NO | NO | YES\n"
"| `reset [commit]` | REF | YES | NO | YES\n"
"| `reset --hard [commit]` | REF | YES | YES | *NO*\n"
"| `checkout <commit>` | HEAD | YES | YES | YES\n"
"| *File Level* | | | |\n"
"| `reset [commit] <paths>` | NO | YES | NO | YES\n"
"| `checkout [commit] <paths>` | NO | YES | YES | *NO*\n"
"|================================\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:3
#, no-wrap
msgid ""
"[[_revision_selection]]\n"
"=== Revision Selection\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:6
#, no-wrap
msgid ""
"Git allows you to refer to a single commit, set of commits, or range of "
"commits in a number of ways.\n"
"They aren't necessarily obvious but are helpful to know.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:8
#, no-wrap
msgid "==== Single Revisions\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:11
#, no-wrap
msgid ""
"You can obviously refer to any single commit by its full, 40-character SHA-1 "
"hash, but there are more human-friendly ways to refer to commits as well.\n"
"This section outlines the various ways you can refer to any commit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:13
#, no-wrap
msgid "==== Short SHA-1\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:15
#, no-wrap
msgid ""
"Git is smart enough to figure out what commit you're referring to if you "
"provide the first few characters of the SHA-1 hash, as long as that partial "
"hash is at least four characters long and unambiguous; that is, no other "
"object in the object database can have a hash that begins with the same "
"prefix.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:17
#, no-wrap
msgid ""
"For example, to examine a specific commit where you know you added certain "
"functionality, you might first run the `git log` command to locate the "
"commit:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:24
#, no-wrap
msgid ""
"$ git log\n"
"commit 734713bc047d87bf7eac9674765ae793478c50d3\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Fri Jan 2 18:32:33 2009 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:26
#: book/07-git-tools/sections/revision-selection.asc:165
#, no-wrap
msgid "    Fix refs handling, add gc auto, update tests\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:31
#, no-wrap
msgid ""
"commit d921970aadf03b3cf0e71becdaab3147ba71cdef\n"
"Merge: 1c002dd... 35cfb2b...\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Thu Dec 11 15:08:43 2008 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:33
#, no-wrap
msgid "    Merge commit 'phedders/rdocs'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:37
#, no-wrap
msgid ""
"commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Thu Dec 11 14:58:32 2008 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:39
#, no-wrap
msgid ""
"    Add some blame and merge stuff\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:43
#, no-wrap
msgid ""
"In this case, say you're interested in the commit whose hash begins with "
"`1c002dd...`.\n"
"You can inspect that commit with any of the following variations of `git "
"show` (assuming the shorter versions are unambiguous):\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:49
#, no-wrap
msgid ""
"$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n"
"$ git show 1c002dd4b536e7479f\n"
"$ git show 1c002d\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:53
#, no-wrap
msgid ""
"Git can figure out a short, unique abbreviation for your SHA-1 values.\n"
"If you pass `--abbrev-commit` to the `git log` command, the output will use "
"shorter values but keep them unique; it defaults to using seven characters "
"but makes them longer if necessary to keep the SHA-1 unambiguous:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:60
#, no-wrap
msgid ""
"$ git log --abbrev-commit --pretty=oneline\n"
"ca82a6d Change the version number\n"
"085bb3b Remove unnecessary test code\n"
"a11bef0 Initial commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:64
#, no-wrap
msgid ""
"Generally, eight to ten characters are more than enough to be unique within "
"a project.\n"
"For example, as of February 2019, the Linux kernel (which is a fairly "
"sizable project) has over 875,000 commits and almost seven million objects "
"in its object database, with no two objects whose SHA-1s are identical in "
"the first 12 characters.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:67
#, no-wrap
msgid ""
"[NOTE]\n"
".A SHORT NOTE ABOUT SHA-1\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:71
#, no-wrap
msgid ""
"A lot of people become concerned at some point that they will, by random "
"happenstance, have two distinct objects in their repository that hash to the "
"same SHA-1 value.\n"
"What then?\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:74
#, no-wrap
msgid ""
"If you do happen to commit an object that hashes to the same SHA-1 value as "
"a previous _different_ object in your repository, Git will see the previous "
"object already in your Git database, assume it was already written and "
"simply reuse it.\n"
"If you try to check out that object again at some point, you'll always get "
"the data of the first object.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:82
#, no-wrap
msgid ""
"However, you should be aware of how ridiculously unlikely this scenario "
"is.\n"
"The SHA-1 digest is 20 bytes or 160 bits.\n"
"The number of randomly hashed objects needed to ensure a 50% probability of "
"a single collision is about 2^80^\n"
"(the formula for determining collision probability is `p = (n(n-1)/2) * "
"(1/2^160))`. 2^80^\n"
"is 1.2 x 10^24^\n"
"or 1 million billion billion.\n"
"That's 1,200 times the number of grains of sand on the earth.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:86
#, no-wrap
msgid ""
"Here's an example to give you an idea of what it would take to get a SHA-1 "
"collision.\n"
"If all 6.5 billion humans on Earth were programming, and every second, each "
"one was producing code that was the equivalent of the entire Linux kernel "
"history (6.5 million Git objects) and pushing it into one enormous Git "
"repository, it would take roughly 2 years until that repository contained "
"enough objects to have a 50% probability of a single SHA-1 object "
"collision.\n"
"Thus, an organic SHA-1 collision is less likely than every member of your "
"programming team being attacked and killed by wolves in unrelated incidents "
"on the same night.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:89
#, no-wrap
msgid ""
"If you dedicate several thousands of dollars' worth of computing power to "
"it, it is possible to synthesize two files with the same hash, as proven on "
"https://shattered.io/[] in February 2017.\n"
"Git is moving towards using SHA256 as the default hashing algorithm, which "
"is much more resilient to collision attacks, and has code in place to help "
"mitigate this attack (although it cannot completely eliminate it).\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:93
#, no-wrap
msgid ""
"[[_branch_references]]\n"
"==== Branch References\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:96
#, no-wrap
msgid ""
"One straightforward way to refer to a particular commit is if it's the "
"commit at the tip of a branch; in that case, you can simply use the branch "
"name in any Git command that expects a reference to a commit.\n"
"For instance, if you want to examine the last commit object on a branch, the "
"following commands are equivalent, assuming that the `topic1` branch points "
"to commit `ca82a6d...`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:101
#, no-wrap
msgid ""
"$ git show ca82a6dff817ec66f44342007202690a93763949\n"
"$ git show topic1\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:107
#, no-wrap
msgid ""
"If you want to see which specific SHA-1 a branch points to, or if you want "
"to see what any of these examples boils down to in terms of SHA-1s, you can "
"use a Git plumbing tool called `rev-parse`.\n"
"You can see <<ch10-git-internals#ch10-git-internals>> for more information "
"about plumbing tools; basically, `rev-parse` exists for lower-level "
"operations and isn't designed to be used in day-to-day operations.\n"
"However, it can be helpful sometimes when you need to see what's really "
"going on.\n"
"Here you can run `rev-parse` on your branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:112
#, no-wrap
msgid ""
"$ git rev-parse topic1\n"
"ca82a6dff817ec66f44342007202690a93763949\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:116
#, no-wrap
msgid ""
"[[_git_reflog]]\n"
"==== RefLog Shortnames\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:118
#, no-wrap
msgid ""
"One of the things Git does in the background while you're working away is "
"keep a \"`reflog`\" -- a log of where your HEAD and branch references have "
"been for the last few months.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:120
#, no-wrap
msgid "You can see your reflog by using `git reflog`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:131
#, no-wrap
msgid ""
"$ git reflog\n"
"734713b HEAD@{0}: commit: Fix refs handling, add gc auto, update tests\n"
"d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' "
"strategy.\n"
"1c002dd HEAD@{2}: commit: Add some blame and merge stuff\n"
"1c36188 HEAD@{3}: rebase -i (squash): updating HEAD\n"
"95df984 HEAD@{4}: commit: # This is a combination of two commits.\n"
"1c36188 HEAD@{5}: rebase -i (squash): updating HEAD\n"
"7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:136
#, no-wrap
msgid ""
"Every time your branch tip is updated for any reason, Git stores that "
"information for you in this temporary history.\n"
"You can use your reflog data to refer to older commits as well.\n"
"For example, if you want to see the fifth prior value of the HEAD of your "
"repository, you can use the `@{5}` reference that you see in the reflog "
"output:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:140
#, no-wrap
msgid ""
"$ git show HEAD@{5}\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:144
#, no-wrap
msgid ""
"You can also use this syntax to see where a branch was some specific amount "
"of time ago.\n"
"For instance, to see where your `master` branch was yesterday, you can "
"type:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:148
#, no-wrap
msgid ""
"$ git show master@{yesterday}\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:152
#, no-wrap
msgid ""
"That would show you where tip of your `master` branch was yesterday.\n"
"This technique only works for data that's still in your reflog, so you can't "
"use it to look for commits older than a few months.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:154
#, no-wrap
msgid ""
"To see reflog information formatted like the `git log` output, you can run "
"`git log -g`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:163
#, no-wrap
msgid ""
"$ git log -g master\n"
"commit 734713bc047d87bf7eac9674765ae793478c50d3\n"
"Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)\n"
"Reflog message: commit: Fix refs handling, add gc auto, update tests\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Fri Jan 2 18:32:33 2009 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:171
#, no-wrap
msgid ""
"commit d921970aadf03b3cf0e71becdaab3147ba71cdef\n"
"Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)\n"
"Reflog message: merge phedders/rdocs: Merge made by recursive.\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Thu Dec 11 15:08:43 2008 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:173
#: book/07-git-tools/sections/revision-selection.asc:231
#, no-wrap
msgid ""
"    Merge commit 'phedders/rdocs'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:178
#, no-wrap
msgid ""
"It's important to note that reflog information is strictly local -- it's a "
"log only of what _you've_ done in _your_ repository.\n"
"The references won't be the same on someone else's copy of the repository; "
"also, right after you initially clone a repository, you'll have an empty "
"reflog, as no activity has occurred yet in your repository.\n"
"Running `git show HEAD@{2.months.ago}` will show you the matching commit "
"only if you cloned the project at least two months ago -- if you cloned it "
"any more recently than that, you'll see only your first local commit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:181
#, no-wrap
msgid ""
"[TIP]\n"
".Think of the reflog as Git's version of shell history\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:183
#, no-wrap
msgid ""
"If you have a UNIX or Linux background, you can think of the reflog as Git's "
"version of shell history, which emphasizes that what's there is clearly "
"relevant only for you and your \"`session`\", and has nothing to do with "
"anyone else who might be working on the same machine.\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:187
#, no-wrap
msgid ""
"[NOTE]\n"
".Escaping braces in PowerShell\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:191
#, no-wrap
msgid ""
"When using PowerShell, braces like `{` and `}` are special characters and "
"must be escaped.\n"
"You can escape them with a backtick ` or put the commit reference in "
"quotes:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:197
#, no-wrap
msgid ""
"$ git show HEAD@{0}     # will NOT work\n"
"$ git show HEAD@`{0`}   # OK\n"
"$ git show \"HEAD@{0}\"   # OK\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:199
#: book/07-git-tools/sections/revision-selection.asc:247
#: book/07-git-tools/sections/rewriting-history.asc:53
#, no-wrap
msgid "====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:202
#, no-wrap
msgid "==== Ancestry References\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:206
#, no-wrap
msgid ""
"The other main way to specify a commit is via its ancestry.\n"
"If you place a `^` (caret) at the end of a reference, Git resolves it to "
"mean the parent of that commit.\n"
"Suppose you look at the history of your project:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:218
#, no-wrap
msgid ""
"$ git log --pretty=format:'%h %s' --graph\n"
"* 734713b Fix refs handling, add gc auto, update tests\n"
"*   d921970 Merge commit 'phedders/rdocs'\n"
"|\\\n"
"| * 35cfb2b Some rdoc changes\n"
"* | 1c002dd Add some blame and merge stuff\n"
"|/\n"
"* 1c36188 Ignore *.gem\n"
"* 9b29157 Add open3_detach to gemspec file list\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:221
#, no-wrap
msgid ""
"Then, you can see the previous commit by specifying `HEAD^`, which means "
"\"`the parent of HEAD`\":\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:229
#, no-wrap
msgid ""
"$ git show HEAD^\n"
"commit d921970aadf03b3cf0e71becdaab3147ba71cdef\n"
"Merge: 1c002dd... 35cfb2b...\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Thu Dec 11 15:08:43 2008 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:235
#, no-wrap
msgid ""
"[NOTE]\n"
".Escaping the caret on Windows\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:239
#, no-wrap
msgid ""
"On Windows in `cmd.exe`, `^` is a special character and needs to be treated "
"differently.\n"
"You can either double it or put the commit reference in quotes:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:245
#, no-wrap
msgid ""
"$ git show HEAD^     # will NOT work on Windows\n"
"$ git show HEAD^^    # OK\n"
"$ git show \"HEAD^\"   # OK\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:251
#, no-wrap
msgid ""
"You can also specify a number after the `^` to identify _which_ parent you "
"want; for example, `d921970^2` means \"`the second parent of d921970.`\"\n"
"This syntax is useful only for merge commits, which have more than one "
"parent -- the _first_ parent of a merge commit is from the branch you were "
"on when you merged (frequently `master`), while the _second_ parent of a "
"merge commit is from the branch that was merged (say, `topic`):\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:258
#, no-wrap
msgid ""
"$ git show d921970^\n"
"commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Thu Dec 11 14:58:32 2008 -0800\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:260
#, no-wrap
msgid "    Add some blame and merge stuff\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:265
#, no-wrap
msgid ""
"$ git show d921970^2\n"
"commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\n"
"Author: Paul Hedderly <paul+git@mjr.org>\n"
"Date:   Wed Dec 10 22:22:03 2008 +0000\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:267
#, no-wrap
msgid ""
"    Some rdoc changes\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:274
#, no-wrap
msgid ""
"The other main ancestry specification is the `~` (tilde).\n"
"This also refers to the first parent, so `HEAD~` and `HEAD^` are "
"equivalent.\n"
"The difference becomes apparent when you specify a number.\n"
"`HEAD~2` means \"`the first parent of the first parent,`\" or \"`the "
"grandparent`\" -- it traverses the first parents the number of times you "
"specify.\n"
"For example, in the history listed earlier, `HEAD~3` would be:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:281
#, no-wrap
msgid ""
"$ git show HEAD~3\n"
"commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\n"
"Author: Tom Preston-Werner <tom@mojombo.com>\n"
"Date:   Fri Nov 7 13:47:59 2008 -0500\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:283
#: book/07-git-tools/sections/revision-selection.asc:295
#, no-wrap
msgid ""
"    Ignore *.gem\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:286
#, no-wrap
msgid ""
"This can also be written `HEAD\\~~~`, which again is the first parent of the "
"first parent of the first parent:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:293
#, no-wrap
msgid ""
"$ git show HEAD~~~\n"
"commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\n"
"Author: Tom Preston-Werner <tom@mojombo.com>\n"
"Date:   Fri Nov 7 13:47:59 2008 -0500\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:298
#, no-wrap
msgid ""
"You can also combine these syntaxes -- you can get the second parent of the "
"previous reference (assuming it was a merge commit) by using `HEAD~3^2`, and "
"so on.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:301
#, no-wrap
msgid ""
"[[_commit_ranges]]\n"
"==== Commit Ranges\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:304
#, no-wrap
msgid ""
"Now that you can specify individual commits, let's see how to specify ranges "
"of commits.\n"
"This is particularly useful for managing your branches -- if you have a lot "
"of branches, you can use range specifications to answer questions such as, "
"\"`What work is on this branch that I haven't yet merged into my main "
"branch?`\"\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:306
#, no-wrap
msgid "===== Double Dot\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:310
#, no-wrap
msgid ""
"The most common range specification is the double-dot syntax.\n"
"This basically asks Git to resolve a range of commits that are reachable "
"from one commit but aren't reachable from another.\n"
"For example, say you have a commit history that looks like <<double_dot>>.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:314
#, no-wrap
msgid ""
"[[double_dot]]\n"
".Example history for range selection\n"
"image::images/double-dot.png[Example history for range selection]\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:318
#, no-wrap
msgid ""
"Say you want to see what is in your `experiment` branch that hasn't yet been "
"merged into your `master` branch.\n"
"You can ask Git to show you a log of just those commits with "
"`master..experiment` -- that means \"`all commits reachable from "
"`experiment` that aren't reachable from `master`.`\"\n"
"For the sake of brevity and clarity in these examples, the letters of the "
"commit objects from the diagram are used in place of the actual log output "
"in the order that they would display:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:324
#, no-wrap
msgid ""
"$ git log master..experiment\n"
"D\n"
"C\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:328
#, no-wrap
msgid ""
"If, on the other hand, you want to see the opposite -- all commits in "
"`master` that aren't in `experiment` -- you can reverse the branch names.\n"
"`experiment..master` shows you everything in `master` not reachable from "
"`experiment`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:334
#, no-wrap
msgid ""
"$ git log experiment..master\n"
"F\n"
"E\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:338
#, no-wrap
msgid ""
"This is useful if you want to keep the `experiment` branch up to date and "
"preview what you're about to merge.\n"
"Another frequent use of this syntax is to see what you're about to push to a "
"remote:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:342
#, no-wrap
msgid ""
"$ git log origin/master..HEAD\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:348
#, no-wrap
msgid ""
"This command shows you any commits in your current branch that aren't in the "
"`master` branch on your `origin` remote.\n"
"If you run a `git push` and your current branch is tracking `origin/master`, "
"the commits listed by `git log origin/master..HEAD` are the commits that "
"will be transferred to the server.\n"
"You can also leave off one side of the syntax to have Git assume `HEAD`.\n"
"For example, you can get the same results as in the previous example by "
"typing `git log origin/master..` -- Git substitutes `HEAD` if one side is "
"missing.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:350
#, no-wrap
msgid "===== Multiple Points\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:354
#, no-wrap
msgid ""
"The double-dot syntax is useful as a shorthand, but perhaps you want to "
"specify more than two branches to indicate your revision, such as seeing "
"what commits are in any of several branches that aren't in the branch you're "
"currently on.\n"
"Git allows you to do this by using either the `^` character or `--not` "
"before any reference from which you don't want to see reachable commits.\n"
"Thus, the following three commands are equivalent:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:360
#, no-wrap
msgid ""
"$ git log refA..refB\n"
"$ git log ^refA refB\n"
"$ git log refB --not refA\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:364
#, no-wrap
msgid ""
"This is nice because with this syntax you can specify more than two "
"references in your query, which you cannot do with the double-dot syntax.\n"
"For instance, if you want to see all commits that are reachable from `refA` "
"or `refB` but not from `refC`, you can use either of:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:369
#, no-wrap
msgid ""
"$ git log refA refB ^refC\n"
"$ git log refA refB --not refC\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:372
#, no-wrap
msgid ""
"This makes for a very powerful revision query system that should help you "
"figure out what is in your branches.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:375
#, no-wrap
msgid ""
"[[_triple_dot]]\n"
"===== Triple Dot\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:379
#, no-wrap
msgid ""
"The last major range-selection syntax is the triple-dot syntax, which "
"specifies all the commits that are reachable by _either_ of two references "
"but not by both of them.\n"
"Look back at the example commit history in <<double_dot>>.\n"
"If you want to see what is in `master` or `experiment` but not any common "
"references, you can run:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:387
#, no-wrap
msgid ""
"$ git log master...experiment\n"
"F\n"
"E\n"
"D\n"
"C\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:390
#, no-wrap
msgid ""
"Again, this gives you normal `log` output but shows you only the commit "
"information for those four commits, appearing in the traditional commit date "
"ordering.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:393
#, no-wrap
msgid ""
"A common switch to use with the `log` command in this case is "
"`--left-right`, which shows you which side of the range each commit is in.\n"
"This helps make the output more useful:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:401
#, no-wrap
msgid ""
"$ git log --left-right master...experiment\n"
"< F\n"
"< E\n"
"> D\n"
"> C\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/revision-selection.asc:403
#, no-wrap
msgid ""
"With these tools, you can much more easily let Git know what commit or "
"commits you want to inspect.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:3
#, no-wrap
msgid ""
"[[_rewriting_history]]\n"
"=== Rewriting History\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:8
#, no-wrap
msgid ""
"Many times, when working with Git, you may want to revise your local commit "
"history.\n"
"One of the great things about Git is that it allows you to make decisions at "
"the last possible moment.\n"
"You can decide what files go into which commits right before you commit with "
"the staging area, you can decide that you didn't mean to be working on "
"something yet with `git stash`, and you can rewrite commits that already "
"happened so they look like they happened in a different way.\n"
"This can involve changing the order of the commits, changing messages or "
"modifying files in a commit, squashing together or splitting apart commits, "
"or removing commits entirely -- all before you share your work with "
"others.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:10
#, no-wrap
msgid ""
"In this section, you'll see how to accomplish these tasks so that you can "
"make your commit history look the way you want before you share it with "
"others.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:13
#, no-wrap
msgid ""
"[NOTE]\n"
".Don't push your work until you're happy with it\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:17
#, no-wrap
msgid ""
"One of the cardinal rules of Git is that, since so much work is local within "
"your clone, you have a great deal of freedom to rewrite your history "
"_locally_.\n"
"However, once you push your work, it is a different story entirely, and you "
"should consider pushed work as final unless you have good reason to change "
"it.\n"
"In short, you should avoid pushing your work until you're happy with it and "
"ready to share it with the rest of the world.\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:21
#, no-wrap
msgid ""
"[[_git_amend]]\n"
"==== Changing the Last Commit\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:24
#, no-wrap
msgid ""
"Changing your most recent commit is probably the most common rewriting of "
"history that you'll do.\n"
"You'll often want to do two basic things to your last commit: simply change "
"the commit message, or change the actual content of the commit by adding, "
"removing and modifying files.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:26
#, no-wrap
msgid "If you simply want to modify your last commit message, that's easy:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:30
#: book/07-git-tools/sections/rewriting-history.asc:158
#, no-wrap
msgid ""
"$ git commit --amend\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:34
#, no-wrap
msgid ""
"The command above loads the previous commit message into an editor session, "
"where you can make changes to the message, save those changes and exit.\n"
"When you save and close the editor, the editor writes a new commit "
"containing that updated commit message and makes it your new last commit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:36
#, no-wrap
msgid ""
"If, on the other hand, you want to change the actual _content_ of your last "
"commit, the process works basically the same way -- first make the changes "
"you think you forgot, stage those changes, and the subsequent `git commit "
"--amend` _replaces_ that last commit with your new, improved commit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:39
#, no-wrap
msgid ""
"You need to be careful with this technique because amending changes the "
"SHA-1 of the commit.\n"
"It's like a very small rebase -- don't amend your last commit if you've "
"already pushed it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:42
#, no-wrap
msgid ""
"[TIP]\n"
".An amended commit may (or may not) need an amended commit message\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:45
#, no-wrap
msgid ""
"When you amend a commit, you have the opportunity to change both the commit "
"message and the content of the commit.\n"
"If you amend the content of the commit substantially, you should almost "
"certainly update the commit message to reflect that amended content.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:47
#, no-wrap
msgid ""
"On the other hand, if your amendments are suitably trivial (fixing a silly "
"typo or adding a file you forgot to stage) such that the earlier commit "
"message is just fine, you can simply make the changes, stage them, and avoid "
"the unnecessary editor session entirely with:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:51
#, no-wrap
msgid ""
"$ git commit --amend --no-edit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:57
#, no-wrap
msgid ""
"[[_changing_multiple]]\n"
"==== Changing Multiple Commit Messages\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:63
#, no-wrap
msgid ""
"To modify a commit that is farther back in your history, you must move to "
"more complex tools.\n"
"Git doesn't have a modify-history tool, but you can use the rebase tool to "
"rebase a series of commits onto the HEAD that they were originally based on "
"instead of moving them to another one.\n"
"With the interactive rebase tool, you can then stop after each commit you "
"want to modify and change the message, add files, or do whatever you wish.\n"
"You can run rebase interactively by adding the `-i` option to `git "
"rebase`.\n"
"You must indicate how far back you want to rewrite commits by telling the "
"command which commit to rebase onto.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:66
#, no-wrap
msgid ""
"For example, if you want to change the last three commit messages, or any of "
"the commit messages in that group, you supply as an argument to `git rebase "
"-i` the parent of the last commit you want to edit, which is `HEAD~2^` or "
"`HEAD~3`.\n"
"It may be easier to remember the `~3` because you're trying to edit the last "
"three commits, but keep in mind that you're actually designating four "
"commits ago, the parent of the last commit you want to edit:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:70
#, no-wrap
msgid ""
"$ git rebase -i HEAD~3\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:74
#, no-wrap
msgid ""
"Remember again that this is a rebasing command -- every commit in the range "
"`HEAD~3..HEAD` with a changed message _and all of its descendants_ will be "
"rewritten.\n"
"Don't include any commit you've already pushed to a central server -- doing "
"so will confuse other developers by providing an alternate version of the "
"same change.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:76
#, no-wrap
msgid ""
"Running this command gives you a list of commits in your text editor that "
"looks something like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:82
#, no-wrap
msgid ""
"pick f7f3f6d Change my name a bit\n"
"pick 310154e Update README formatting and add blame\n"
"pick a5f4a0d Add cat-file\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:108
#, no-wrap
msgid ""
"# Rebase 710f0f8..a5f4a0d onto 710f0f8\n"
"#\n"
"# Commands:\n"
"# p, pick <commit> = use commit\n"
"# r, reword <commit> = use commit, but edit the commit message\n"
"# e, edit <commit> = use commit, but stop for amending\n"
"# s, squash <commit> = use commit, but meld into previous commit\n"
"# f, fixup <commit> = like \"squash\", but discard this commit's log "
"message\n"
"# x, exec <command> = run command (the rest of the line) using shell\n"
"# b, break = stop here (continue rebase later with 'git rebase "
"--continue')\n"
"# d, drop <commit> = remove commit\n"
"# l, label <label> = label current HEAD with a name\n"
"# t, reset <label> = reset HEAD to a label\n"
"# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n"
"# .       create a merge commit using the original merge commit's\n"
"# .       message (or the oneline, if no original merge commit was\n"
"# .       specified). Use -c <commit> to reword the commit message.\n"
"#\n"
"# These lines can be re-ordered; they are executed from top to bottom.\n"
"#\n"
"# If you remove a line here THAT COMMIT WILL BE LOST.\n"
"#\n"
"# However, if you remove everything, the rebase will be aborted.\n"
"#\n"
"# Note that empty commits are commented out\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:112
#, no-wrap
msgid ""
"It's important to note that these commits are listed in the opposite order "
"than you normally see them using the `log` command.\n"
"If you run a `log`, you see something like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:119
#, no-wrap
msgid ""
"$ git log --pretty=format:\"%h %s\" HEAD~3..HEAD\n"
"a5f4a0d Add cat-file\n"
"310154e Update README formatting and add blame\n"
"f7f3f6d Change my name a bit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:125
#, no-wrap
msgid ""
"Notice the reverse order.\n"
"The interactive rebase gives you a script that it's going to run.\n"
"It will start at the commit you specify on the command line (`HEAD~3`) and "
"replay the changes introduced in each of these commits from top to bottom.\n"
"It lists the oldest at the top, rather than the newest, because that's the "
"first one it will replay.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:129
#, no-wrap
msgid ""
"You need to edit the script so that it stops at the commit you want to "
"edit.\n"
"To do so, change the word \"`pick`\" to the word \"`edit`\" for each of the "
"commits you want the script to stop after.\n"
"For example, to modify only the third commit message, you change the file to "
"look like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:135
#, no-wrap
msgid ""
"edit f7f3f6d Change my name a bit\n"
"pick 310154e Update README formatting and add blame\n"
"pick a5f4a0d Add cat-file\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:138
#, no-wrap
msgid ""
"When you save and exit the editor, Git rewinds you back to the last commit "
"in that list and drops you on the command line with the following message:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:144
#, no-wrap
msgid ""
"$ git rebase -i HEAD~3\n"
"Stopped at f7f3f6d... Change my name a bit\n"
"You can amend the commit now, with\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:146
#, no-wrap
msgid "       git commit --amend\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:148
#, no-wrap
msgid "Once you're satisfied with your changes, run\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:150
#, no-wrap
msgid ""
"       git rebase --continue\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:154
#, no-wrap
msgid ""
"These instructions tell you exactly what to do.\n"
"Type:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:162
#, no-wrap
msgid ""
"Change the commit message, and exit the editor.\n"
"Then, run:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:166
#, no-wrap
msgid ""
"$ git rebase --continue\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:171
#, no-wrap
msgid ""
"This command will apply the other two commits automatically, and then you're "
"done.\n"
"If you change pick to edit on more lines, you can repeat these steps for "
"each commit you change to edit.\n"
"Each time, Git will stop, let you amend the commit, and continue when you're "
"finished.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:173
#, no-wrap
msgid "==== Reordering Commits\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:176
#, no-wrap
msgid ""
"You can also use interactive rebases to reorder or remove commits "
"entirely.\n"
"If you want to remove the \"`Add cat-file`\" commit and change the order in "
"which the other two commits are introduced, you can change the rebase script "
"from this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:182
#, no-wrap
msgid ""
"pick f7f3f6d Change my name a bit\n"
"pick 310154e Update README formatting and add blame\n"
"pick a5f4a0d Add cat-file\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:185
#, no-wrap
msgid "to this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:190
#, no-wrap
msgid ""
"pick 310154e Update README formatting and add blame\n"
"pick f7f3f6d Change my name a bit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:194
#, no-wrap
msgid ""
"When you save and exit the editor, Git rewinds your branch to the parent of "
"these commits, applies `310154e` and then `f7f3f6d`, and then stops.\n"
"You effectively change the order of those commits and remove the \"`Add "
"cat-file`\" commit completely.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:197
#, no-wrap
msgid ""
"[[_squashing]]\n"
"==== Squashing Commits\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:200
#, no-wrap
msgid ""
"It's also possible to take a series of commits and squash them down into a "
"single commit with the interactive rebasing tool.\n"
"The script puts helpful instructions in the rebase message:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:227
#, no-wrap
msgid ""
"#\n"
"# Commands:\n"
"# p, pick <commit> = use commit\n"
"# r, reword <commit> = use commit, but edit the commit message\n"
"# e, edit <commit> = use commit, but stop for amending\n"
"# s, squash <commit> = use commit, but meld into previous commit\n"
"# f, fixup <commit> = like \"squash\", but discard this commit's log "
"message\n"
"# x, exec <command> = run command (the rest of the line) using shell\n"
"# b, break = stop here (continue rebase later with 'git rebase "
"--continue')\n"
"# d, drop <commit> = remove commit\n"
"# l, label <label> = label current HEAD with a name\n"
"# t, reset <label> = reset HEAD to a label\n"
"# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n"
"# .       create a merge commit using the original merge commit's\n"
"# .       message (or the oneline, if no original merge commit was\n"
"# .       specified). Use -c <commit> to reword the commit message.\n"
"#\n"
"# These lines can be re-ordered; they are executed from top to bottom.\n"
"#\n"
"# If you remove a line here THAT COMMIT WILL BE LOST.\n"
"#\n"
"# However, if you remove everything, the rebase will be aborted.\n"
"#\n"
"# Note that empty commits are commented out\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:231
#, no-wrap
msgid ""
"If, instead of \"`pick`\" or \"`edit`\", you specify \"`squash`\", Git "
"applies both that change and the change directly before it and makes you "
"merge the commit messages together.\n"
"So, if you want to make a single commit from these three commits, you make "
"the script look like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:237
#, no-wrap
msgid ""
"pick f7f3f6d Change my name a bit\n"
"squash 310154e Update README formatting and add blame\n"
"squash a5f4a0d Add cat-file\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:240
#, no-wrap
msgid ""
"When you save and exit the editor, Git applies all three changes and then "
"puts you back into the editor to merge the three commit messages:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:246
#, no-wrap
msgid ""
"# This is a combination of 3 commits.\n"
"# The first commit's message is:\n"
"Change my name a bit\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:248
#, no-wrap
msgid "# This is the 2nd commit message:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:250
#, no-wrap
msgid "Update README formatting and add blame\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:252
#, no-wrap
msgid "# This is the 3rd commit message:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:254
#, no-wrap
msgid ""
"Add cat-file\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:257
#, no-wrap
msgid ""
"When you save that, you have a single commit that introduces the changes of "
"all three previous commits.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:259
#, no-wrap
msgid "==== Splitting a Commit\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:264
#, no-wrap
msgid ""
"Splitting a commit undoes a commit and then partially stages and commits as "
"many times as commits you want to end up with.\n"
"For example, suppose you want to split the middle commit of your three "
"commits.\n"
"Instead of \"`Update README formatting and add blame`\", you want to split "
"it into two commits: \"`Update README formatting`\" for the first, and "
"\"`Add blame`\" for the second.\n"
"You can do that in the `rebase -i` script by changing the instruction on the "
"commit you want to split to \"`edit`\":\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:270
#, no-wrap
msgid ""
"pick f7f3f6d Change my name a bit\n"
"edit 310154e Update README formatting and add blame\n"
"pick a5f4a0d Add cat-file\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:276
#, no-wrap
msgid ""
"Then, when the script drops you to the command line, you reset that commit, "
"take the changes that have been reset, and create multiple commits out of "
"them.\n"
"When you save and exit the editor, Git rewinds to the parent of the first "
"commit in your list, applies the first commit (`f7f3f6d`), applies the "
"second (`310154e`), and drops you to the console.\n"
"There, you can do a mixed reset of that commit with `git reset HEAD^`, which "
"effectively undoes that commit and leaves the modified files unstaged.\n"
"Now you can stage and commit files until you have several commits, and run "
"`git rebase --continue` when you're done:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:285
#, no-wrap
msgid ""
"$ git reset HEAD^\n"
"$ git add README\n"
"$ git commit -m 'Update README formatting'\n"
"$ git add lib/simplegit.rb\n"
"$ git commit -m 'Add blame'\n"
"$ git rebase --continue\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:288
#, no-wrap
msgid ""
"Git applies the last commit (`a5f4a0d`) in the script, and your history "
"looks like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:296
#, no-wrap
msgid ""
"$ git log -4 --pretty=format:\"%h %s\"\n"
"1c002dd Add cat-file\n"
"9b29157 Add blame\n"
"35cfb2b Update README formatting\n"
"f7f3f6d Change my name a bit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:301
#, no-wrap
msgid ""
"This changes the SHA-1s of the three most recent commits in your list, so "
"make sure no changed commit shows up in that list that you've already pushed "
"to a shared repository.\n"
"Notice that the last commit (`f7f3f6d`) in the list is unchanged.\n"
"Despite this commit being shown in the script, because it was marked as "
"\"`pick`\" and was applied prior to any rebase changes, Git leaves the "
"commit unmodified.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:303
#, no-wrap
msgid "==== Deleting a commit\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:306
#, no-wrap
msgid ""
"If you want to get rid of a commit, you can delete it using the `rebase -i` "
"script.\n"
"In the list of commits, put the word \"`drop`\" before the commit you want "
"to delete (or just delete that line from the rebase script):\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:311
#, no-wrap
msgid ""
"pick 461cb2a This commit is OK\n"
"drop 5aecc10 This commit is broken\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:316
#, no-wrap
msgid ""
"Because of the way Git builds commit objects, deleting or altering a commit "
"will cause the rewriting of all the commits that follow it.\n"
"The further back in your repo's history you go, the more commits will need "
"to be recreated.\n"
"This can cause lots of merge conflicts if you have many commits later in the "
"sequence that depend on the one you just deleted.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:319
#, no-wrap
msgid ""
"If you get partway through a rebase like this and decide it's not a good "
"idea, you can always stop.\n"
"Type `git rebase --abort`, and your repo will be returned to the state it "
"was in before you started the rebase.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:322
#, no-wrap
msgid ""
"If you finish a rebase and decide it's not what you want, you can use `git "
"reflog` to recover an earlier version of your branch.\n"
"See <<ch10-git-internals#_data_recovery>> for more information on the "
"`reflog` command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:324
#: book/07-git-tools/sections/stashing-cleaning.asc:290
#, no-wrap
msgid ""
"[NOTE]\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:327
#, no-wrap
msgid ""
"Drew DeVault made a practical hands-on guide with exercises to learn how to "
"use `git rebase`.\n"
"You can find it at: https://git-rebase.io/[]\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:330
#, no-wrap
msgid "==== The Nuclear Option: filter-branch\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:335
#, no-wrap
msgid ""
"There is another history-rewriting option that you can use if you need to "
"rewrite a larger number of commits in some scriptable way -- for instance, "
"changing your email address globally or removing a file from every commit.\n"
"The command is `filter-branch`, and it can rewrite huge swaths of your "
"history, so you probably shouldn't use it unless your project isn't yet "
"public and other people haven't based work off the commits you're about to "
"rewrite.\n"
"However, it can be very useful.\n"
"You'll learn a few of the common uses so you can get an idea of some of the "
"things it's capable of.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:337
#, no-wrap
msgid ""
"[CAUTION]\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:341
#, no-wrap
msgid ""
"`git filter-branch` has many pitfalls, and is no longer the recommended way "
"to rewrite history.\n"
"Instead, consider using `git-filter-repo`, which is a Python script that "
"does a better job for most applications where you would normally turn to "
"`filter-branch`.\n"
"Its documentation and source code can be found at "
"https://github.com/newren/git-filter-repo[].\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:345
#, no-wrap
msgid ""
"[[_removing_file_every_commit]]\n"
"===== Removing a File from Every Commit\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:351
#, no-wrap
msgid ""
"This occurs fairly commonly.\n"
"Someone accidentally commits a huge binary file with a thoughtless `git add "
".`, and you want to remove it everywhere.\n"
"Perhaps you accidentally committed a file that contained a password, and you "
"want to make your project open source.\n"
"`filter-branch` is the tool you probably want to use to scrub your entire "
"history.\n"
"To remove a file named `passwords.txt` from your entire history, you can use "
"the `--tree-filter` option to `filter-branch`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:357
#, no-wrap
msgid ""
"$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD\n"
"Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\n"
"Ref 'refs/heads/master' was rewritten\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:362
#, no-wrap
msgid ""
"The `--tree-filter` option runs the specified command after each checkout of "
"the project and then recommits the results.\n"
"In this case, you remove a file called `passwords.txt` from every snapshot, "
"whether it exists or not.\n"
"If you want to remove all accidentally committed editor backup files, you "
"can run something like `git filter-branch --tree-filter 'rm -f *~' HEAD`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:366
#, no-wrap
msgid ""
"You'll be able to watch Git rewriting trees and commits and then move the "
"branch pointer at the end.\n"
"It's generally a good idea to do this in a testing branch and then "
"hard-reset your `master` branch after you've determined the outcome is what "
"you really want.\n"
"To run `filter-branch` on all your branches, you can pass `--all` to the "
"command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:368
#, no-wrap
msgid "===== Making a Subdirectory the New Root\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:371
#, no-wrap
msgid ""
"Suppose you've done an import from another source control system and have "
"subdirectories that make no sense (`trunk`, `tags`, and so on).\n"
"If you want to make the `trunk` subdirectory be the new project root for "
"every commit, `filter-branch` can help you do that, too:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:377
#, no-wrap
msgid ""
"$ git filter-branch --subdirectory-filter trunk HEAD\n"
"Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\n"
"Ref 'refs/heads/master' was rewritten\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:381
#, no-wrap
msgid ""
"Now your new project root is what was in the `trunk` subdirectory each "
"time.\n"
"Git will also automatically remove commits that did not affect the "
"subdirectory.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:383
#, no-wrap
msgid "===== Changing Email Addresses Globally\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:387
#, no-wrap
msgid ""
"Another common case is that you forgot to run `git config` to set your name "
"and email address before you started working, or perhaps you want to "
"open-source a project at work and change all your work email addresses to "
"your personal address.\n"
"In any case, you can change email addresses in multiple commits in a batch "
"with `filter-branch` as well.\n"
"You need to be careful to change only the email addresses that are yours, so "
"you use `--commit-filter`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:399
#, no-wrap
msgid ""
"$ git filter-branch --commit-filter '\n"
"        if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ];\n"
"        then\n"
"                GIT_AUTHOR_NAME=\"Scott Chacon\";\n"
"                GIT_AUTHOR_EMAIL=\"schacon@example.com\";\n"
"                git commit-tree \"$@\";\n"
"        else\n"
"                git commit-tree \"$@\";\n"
"        fi' HEAD\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/rewriting-history.asc:402
#, no-wrap
msgid ""
"This goes through and rewrites every commit to have your new address.\n"
"Because commits contain the SHA-1 values of their parents, this command "
"changes every commit SHA-1 in your history, not just those that have the "
"matching email address.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:3
#, no-wrap
msgid ""
"[[_searching]]\n"
"=== Searching\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:7
#, no-wrap
msgid ""
"With just about any size codebase, you'll often need to find where a "
"function is called or defined, or display the history of a method.\n"
"Git provides a couple of useful tools for looking through the code and "
"commits stored in its database quickly and easily.\n"
"We'll go through a few of them.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:10
#, no-wrap
msgid ""
"[[_git_grep]]\n"
"==== Git Grep\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:13
#, no-wrap
msgid ""
"Git ships with a command called `grep` that allows you to easily search "
"through any committed tree, the working directory, or even the index for a "
"string or regular expression.\n"
"For the examples that follow, we'll search through the source code for Git "
"itself.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:16
#, no-wrap
msgid ""
"By default, `git grep` will look through the files in your working "
"directory.\n"
"As a first variation, you can use either of the `-n` or `--line-number` "
"options to print out the line numbers where Git has found matches:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:31
#, no-wrap
msgid ""
"$ git grep -n gmtime_r\n"
"compat/gmtime.c:3:#undef gmtime_r\n"
"compat/gmtime.c:8:      return git_gmtime_r(timep, &result);\n"
"compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm "
"*result)\n"
"compat/gmtime.c:16:     ret = gmtime_r(timep, result);\n"
"compat/mingw.c:826:struct tm *gmtime_r(const time_t *timep, struct tm "
"*result)\n"
"compat/mingw.h:206:struct tm *gmtime_r(const time_t *timep, struct tm "
"*result);\n"
"date.c:482:             if (gmtime_r(&now, &now_tm))\n"
"date.c:545:             if (gmtime_r(&time, tm)) {\n"
"date.c:758:             /* gmtime_r() in match_digit() may have clobbered it "
"*/\n"
"git-compat-util.h:1138:struct tm *git_gmtime_r(const time_t *, struct tm "
"*);\n"
"git-compat-util.h:1140:#define gmtime_r git_gmtime_r\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:34
#, no-wrap
msgid ""
"In addition to the basic search shown above, `git grep` supports a plethora "
"of other interesting options.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:36
#, no-wrap
msgid ""
"For instance, instead of printing all of the matches, you can ask `git grep` "
"to summarize the output by showing you only which files contained the search "
"string and how many matches there were in each file with the `-c` or "
"`--count` option:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:45
#, no-wrap
msgid ""
"$ git grep --count gmtime_r\n"
"compat/gmtime.c:4\n"
"compat/mingw.c:1\n"
"compat/mingw.h:1\n"
"date.c:3\n"
"git-compat-util.h:2\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:48
#, no-wrap
msgid ""
"If you're interested in the _context_ of a search string, you can display "
"the enclosing method or function for each matching string with either of the "
"`-p` or `--show-function` options:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:58
#, no-wrap
msgid ""
"$ git grep -p gmtime_r *.c\n"
"date.c=static int match_multi_number(timestamp_t num, char c, const char "
"*date,\n"
"date.c:         if (gmtime_r(&now, &now_tm))\n"
"date.c=static int match_digit(const char *date, struct tm *tm, int *offset, "
"int *tm_gmt)\n"
"date.c:         if (gmtime_r(&time, tm)) {\n"
"date.c=int parse_date_basic(const char *date, timestamp_t *timestamp, int "
"*offset)\n"
"date.c:         /* gmtime_r() in match_digit() may have clobbered it */\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:61
#, no-wrap
msgid ""
"As you can see, the `gmtime_r` routine is called from both the "
"`match_multi_number` and `match_digit` functions in the `date.c` file (the "
"third match displayed represents just the string appearing in a comment).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:64
#, no-wrap
msgid ""
"You can also search for complex combinations of strings with the `--and` "
"flag, which ensures that multiple matches must occur in the same line of "
"text.\n"
"For instance, let's look for any lines that define a constant whose name "
"contains _either_ of the substrings \"`LINK`\" or \"`BUF_MAX`\", "
"specifically in an older version of the Git codebase represented by the tag "
"`v1.8.0` (we'll throw in the `--break` and `--heading` options which help "
"split up the output into a more readable format):\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:71
#, no-wrap
msgid ""
"$ git grep --break --heading \\\n"
"    -n -e '#define' --and \\( -e LINK -e BUF_MAX \\) v1.8.0\n"
"v1.8.0:builtin/index-pack.c\n"
"62:#define FLAG_LINK (1u<<20)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:75
#, no-wrap
msgid ""
"v1.8.0:cache.h\n"
"73:#define S_IFGITLINK  0160000\n"
"74:#define S_ISGITLINK(m)       (((m) & S_IFMT) == S_IFGITLINK)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:78
#, no-wrap
msgid ""
"v1.8.0:environment.c\n"
"54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:81
#, no-wrap
msgid ""
"v1.8.0:strbuf.c\n"
"326:#define STRBUF_MAXLINK (2*PATH_MAX)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:84
#, no-wrap
msgid ""
"v1.8.0:symlinks.c\n"
"53:#define FL_SYMLINK  (1 << 2)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:88
#, no-wrap
msgid ""
"v1.8.0:zlib.c\n"
"30:/* #define ZLIB_BUF_MAX ((uInt)-1) */\n"
"31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:93
#, no-wrap
msgid ""
"The `git grep` command has a few advantages over normal searching commands "
"like `grep` and `ack`.\n"
"The first is that it's really fast, the second is that you can search "
"through any tree in Git, not just the working directory.\n"
"As we saw in the above example, we looked for terms in an older version of "
"the Git source code, not the version that was currently checked out.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:95
#, no-wrap
msgid "==== Git Log Searching\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:98
#, no-wrap
msgid ""
"Perhaps you're looking not for _where_ a term exists, but _when_ it existed "
"or was introduced.\n"
"The `git log` command has a number of powerful tools for finding specific "
"commits by the content of their messages or even the content of the diff "
"they introduce.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:100
#, no-wrap
msgid ""
"If, for example, we want to find out when the `ZLIB_BUF_MAX` constant was "
"originally introduced, we can use the `-S` option (colloquially referred to "
"as the Git \"`pickaxe`\" option) to tell Git to show us only those commits "
"that changed the number of occurrences of that string.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:106
#, no-wrap
msgid ""
"$ git log -S ZLIB_BUF_MAX --oneline\n"
"e01503b zlib: allow feeding more than 4GB in one go\n"
"ef49a7a zlib: zlib can only process 4GB at a time\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:109
#, no-wrap
msgid ""
"If we look at the diff of those commits, we can see that in `ef49a7a` the "
"constant was introduced and in `e01503b` it was modified.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:111
#, no-wrap
msgid ""
"If you need to be more specific, you can provide a regular expression to "
"search for with the `-G` option.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:113
#, no-wrap
msgid "===== Line Log Search\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:116
#, no-wrap
msgid ""
"Another fairly advanced log search that is insanely useful is the line "
"history search.\n"
"Simply run `git log` with the `-L` option, and it will show you the history "
"of a function or line of code in your codebase.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:119
#, no-wrap
msgid ""
"For example, if we wanted to see every change made to the function "
"`git_deflate_bound` in the `zlib.c` file, we could run `git log -L "
":git_deflate_bound:zlib.c`.\n"
"This will try to figure out what the bounds of that function are and then "
"look through the history and show us every change that was made to the "
"function as a series of patches back to when the function was first "
"created.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:126
#, no-wrap
msgid ""
"$ git log -L :git_deflate_bound:zlib.c\n"
"commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca\n"
"Author: Junio C Hamano <gitster@pobox.com>\n"
"Date:   Fri Jun 10 11:52:15 2011 -0700\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:128
#, no-wrap
msgid "    zlib: zlib can only process 4GB at a time\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:139
#, no-wrap
msgid ""
"diff --git a/zlib.c b/zlib.c\n"
"--- a/zlib.c\n"
"+++ b/zlib.c\n"
"@@ -85,5 +130,5 @@\n"
"-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)\n"
"+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)\n"
" {\n"
"-       return deflateBound(strm, size);\n"
"+       return deflateBound(&strm->z, size);\n"
" }\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:144
#, no-wrap
msgid ""
"commit 225a6f1068f71723a910e8565db4e252b3ca21fa\n"
"Author: Junio C Hamano <gitster@pobox.com>\n"
"Date:   Fri Jun 10 11:18:17 2011 -0700\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:146
#, no-wrap
msgid "    zlib: wrap deflateBound() too\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:156
#, no-wrap
msgid ""
"diff --git a/zlib.c b/zlib.c\n"
"--- a/zlib.c\n"
"+++ b/zlib.c\n"
"@@ -81,0 +85,5 @@\n"
"+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)\n"
"+{\n"
"+       return deflateBound(strm, size);\n"
"+}\n"
"+\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/searching.asc:160
#, no-wrap
msgid ""
"If Git can't figure out how to match a function or method in your "
"programming language, you can also provide it with a regular expression (or "
"_regex_).\n"
"For example, this would have done the same thing as the example above: `git "
"log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c`.\n"
"You could also give it a range of lines or a single line number and you'll "
"get the same sort of output.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:3
#, no-wrap
msgid ""
"[[_signing]]\n"
"=== Signing Your Work\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:6
#, no-wrap
msgid ""
"Git is cryptographically secure, but it's not foolproof.\n"
"If you're taking work from others on the internet and want to verify that "
"commits are actually from a trusted source, Git has a few ways to sign and "
"verify work using GPG.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:8
#, no-wrap
msgid "==== GPG Introduction\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:10
#, no-wrap
msgid ""
"First of all, if you want to sign anything you need to get GPG configured "
"and your personal key installed.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:15
#, no-wrap
msgid ""
"$ gpg --list-keys\n"
"/Users/schacon/.gnupg/pubring.gpg\n"
"---------------------------------\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:19
#, no-wrap
msgid ""
"pub   2048R/0A46826A 2014-06-04\n"
"uid                  Scott Chacon (Git signing key) <schacon@gmail.com>\n"
"sub   2048R/874529A9 2014-06-04\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:22
#, no-wrap
msgid ""
"If you don't have a key installed, you can generate one with `gpg "
"--gen-key`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:26
#, no-wrap
msgid ""
"$ gpg --gen-key\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:29
#, no-wrap
msgid ""
"Once you have a private key to sign with, you can configure Git to use it "
"for signing things by setting the `user.signingkey` config setting.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:33
#, no-wrap
msgid ""
"$ git config --global user.signingkey 0A46826A\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:36
#, no-wrap
msgid "Now Git will use your key by default to sign tags and commits if you want.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:38
#, no-wrap
msgid "==== Signing Tags\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:41
#, no-wrap
msgid ""
"If you have a GPG private key set up, you can now use it to sign new tags.\n"
"All you have to do is use `-s` instead of `-a`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:45
#, no-wrap
msgid "$ git tag -s v1.5 -m 'my signed 1.5 tag'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:49
#, no-wrap
msgid ""
"You need a passphrase to unlock the secret key for\n"
"user: \"Ben Straub <ben@straub.cc>\"\n"
"2048-bit RSA key, ID 800430EB, created 2014-05-04\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:52
#, no-wrap
msgid ""
"If you run `git show` on that tag, you can see your GPG signature attached "
"to it:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:59
#, no-wrap
msgid ""
"$ git show v1.5\n"
"tag v1.5\n"
"Tagger: Ben Straub <ben@straub.cc>\n"
"Date:   Sat May 3 20:29:41 2014 -0700\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:63
#, no-wrap
msgid ""
"my signed 1.5 tag\n"
"-----BEGIN PGP SIGNATURE-----\n"
"Version: GnuPG v1\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:72
#, no-wrap
msgid ""
"iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut\n"
"LQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b\n"
"hM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm\n"
"ecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp\n"
"8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi\n"
"RUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=\n"
"=EFTF\n"
"-----END PGP SIGNATURE-----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:76
#, no-wrap
msgid ""
"commit ca82a6dff817ec66f44342007202690a93763949\n"
"Author: Scott Chacon <schacon@gee-mail.com>\n"
"Date:   Mon Mar 17 21:52:11 2008 -0700\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:78
#, no-wrap
msgid ""
"    Change version number\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:81
#, no-wrap
msgid "==== Verifying Tags\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:85
#, no-wrap
msgid ""
"To verify a signed tag, you use `git tag -v <tag-name>`.\n"
"This command uses GPG to verify the signature.\n"
"You need the signer's public key in your keyring for this to work "
"properly:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:93
#, no-wrap
msgid ""
"$ git tag -v v1.4.2.1\n"
"object 883653babd8ee7ea23e6a5c392bb739348b1eb61\n"
"type commit\n"
"tag v1.4.2.1\n"
"tagger Junio C Hamano <junkio@cox.net> 1158138501 -0700\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:95
#, no-wrap
msgid "GIT 1.4.2.1\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:101
#, no-wrap
msgid ""
"Minor fixes since 1.4.2, including git-mv and git-http with alternates.\n"
"gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A\n"
"gpg: Good signature from \"Junio C Hamano <junkio@cox.net>\"\n"
"gpg:                 aka \"[jpeg image of size 1513]\"\n"
"Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 "
"9B9A\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:104
#, no-wrap
msgid ""
"If you don't have the signer's public key, you get something like this "
"instead:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:110
#, no-wrap
msgid ""
"gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A\n"
"gpg: Can't check signature: public key not found\n"
"error: could not verify the tag 'v1.4.2.1'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:114
#, no-wrap
msgid ""
"[[_signing_commits]]\n"
"==== Signing Commits\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:117
#, no-wrap
msgid ""
"In more recent versions of Git (v1.7.9 and above), you can now also sign "
"individual commits.\n"
"If you're interested in signing commits directly instead of just the tags, "
"all you need to do is add a `-S` to your `git commit` command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:121
#, no-wrap
msgid "$ git commit -a -S -m 'Signed commit'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:125
#: book/07-git-tools/sections/signing.asc:193
#, no-wrap
msgid ""
"You need a passphrase to unlock the secret key for\n"
"user: \"Scott Chacon (Git signing key) <schacon@gmail.com>\"\n"
"2048-bit RSA key, ID 0A46826A, created 2014-06-04\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:130
#, no-wrap
msgid ""
"[master 5c3386c] Signed commit\n"
" 4 files changed, 4 insertions(+), 24 deletions(-)\n"
" rewrite Rakefile (100%)\n"
" create mode 100644 lib/git.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:133
#, no-wrap
msgid ""
"To see and verify these signatures, there is also a `--show-signature` "
"option to `git log`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:142
#, no-wrap
msgid ""
"$ git log --show-signature -1\n"
"commit 5c3386cf54bba0a33a32da706aa52bc0155503c2\n"
"gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A\n"
"gpg: Good signature from \"Scott Chacon (Git signing key) "
"<schacon@gmail.com>\"\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Wed Jun 4 19:49:17 2014 -0700\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:144
#, no-wrap
msgid ""
"    Signed commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:147
#, no-wrap
msgid ""
"Additionally, you can configure `git log` to check any signatures it finds "
"and list them in its output with the `%G?` format.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:151
#, no-wrap
msgid "$ git log --pretty=\"format:%h %G? %aN  %s\"\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:156
#, no-wrap
msgid ""
"5c3386c G Scott Chacon  Signed commit\n"
"ca82a6d N Scott Chacon  Change the version number\n"
"085bb3b N Scott Chacon  Remove unnecessary test code\n"
"a11bef0 N Scott Chacon  Initial commit\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:159
#, no-wrap
msgid ""
"Here we can see that only the latest commit is signed and valid and the "
"previous commits are not.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:161
#, no-wrap
msgid ""
"In Git 1.8.3 and later, `git merge` and `git pull` can be told to inspect "
"and reject when merging a commit that does not carry a trusted GPG signature "
"with the `--verify-signatures` command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:163
#, no-wrap
msgid ""
"If you use this option when merging a branch and it contains commits that "
"are not signed and valid, the merge will not work.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:168
#, no-wrap
msgid ""
"$ git merge --verify-signatures non-verify\n"
"fatal: Commit ab06180 does not have a GPG signature.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:171
#, no-wrap
msgid ""
"If the merge contains only valid signed commits, the merge command will show "
"you all the signatures it has checked and then move forward with the "
"merge.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:180
#, no-wrap
msgid ""
"$ git merge --verify-signatures signed-branch\n"
"Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) "
"<schacon@gmail.com>\n"
"Updating 5c3386c..13ad65e\n"
"Fast-forward\n"
" README | 2 ++\n"
" 1 file changed, 2 insertions(+)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:184
#, no-wrap
msgid ""
"You can also use the `-S` option with the `git merge` command to sign the "
"resulting merge commit itself.\n"
"The following example both verifies that every commit in the branch to be "
"merged is signed and furthermore signs the resulting merge commit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:189
#, no-wrap
msgid ""
"$ git merge --verify-signatures -S  signed-branch\n"
"Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) "
"<schacon@gmail.com>\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:197
#, no-wrap
msgid ""
"Merge made by the 'recursive' strategy.\n"
" README | 2 ++\n"
" 1 file changed, 2 insertions(+)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:200
#, no-wrap
msgid "==== Everyone Must Sign\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/signing.asc:203
#, no-wrap
msgid ""
"Signing tags and commits is great, but if you decide to use this in your "
"normal workflow, you'll have to make sure that everyone on your team "
"understands how to do so.\n"
"If you don't, you'll end up spending a lot of time helping people figure out "
"how to rewrite their commits with signed versions.\n"
"Make sure you understand GPG and the benefits of signing things before "
"adopting this as part of your standard workflow.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:3
#, no-wrap
msgid ""
"[[_git_stashing]]\n"
"=== Stashing and Cleaning\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:7
#, no-wrap
msgid ""
"Often, when you've been working on part of your project, things are in a "
"messy state and you want to switch branches for a bit to work on something "
"else.\n"
"The problem is, you don't want to do a commit of half-done work just so you "
"can get back to this point later.\n"
"The answer to this issue is the `git stash` command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:9
#, no-wrap
msgid ""
"Stashing takes the dirty state of your working directory -- that is, your "
"modified tracked files and staged changes -- and saves it on a stack of "
"unfinished changes that you can reapply at any time (even on a different "
"branch).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:12
#, no-wrap
msgid ""
"[NOTE]\n"
".Migrating to `git stash push`\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:15
#, no-wrap
msgid ""
"As of late October 2017, there has been extensive discussion on the Git "
"mailing list, wherein the command `git stash save` is being deprecated in "
"favour of the existing alternative `git stash push`.\n"
"The main reason for this is that `git stash push` introduces the option of "
"stashing selected _pathspecs_, something `git stash save` does not "
"support.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:18
#, no-wrap
msgid ""
"`git stash save` is not going away any time soon, so don't worry about it "
"suddenly disappearing.\n"
"But you might want to start migrating over to the `push` alternative for the "
"new functionality.\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:21
#, no-wrap
msgid "==== Stashing Your Work\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:24
#, no-wrap
msgid ""
"To demonstrate stashing, you'll go into your project and start working on a "
"couple of files and possibly stage one of the changes.\n"
"If you run `git status`, you can see your dirty state:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:30
#, no-wrap
msgid ""
"$ git status\n"
"Changes to be committed:\n"
"  (use \"git reset HEAD <file>...\" to unstage)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:32
#: book/07-git-tools/sections/stashing-cleaning.asc:109
#: book/07-git-tools/sections/stashing-cleaning.asc:214
#, no-wrap
msgid "\tmodified:   index.html\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:36
#: book/07-git-tools/sections/stashing-cleaning.asc:113
#: book/07-git-tools/sections/stashing-cleaning.asc:218
#: book/07-git-tools/sections/submodules.asc:297
#: book/07-git-tools/sections/submodules.asc:317
#, no-wrap
msgid ""
"Changes not staged for commit:\n"
"  (use \"git add <file>...\" to update what will be committed)\n"
"  (use \"git checkout -- <file>...\" to discard changes in working "
"directory)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:38
#: book/07-git-tools/sections/stashing-cleaning.asc:115
#, no-wrap
msgid ""
"\tmodified:   lib/simplegit.rb\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:42
#, no-wrap
msgid ""
"Now you want to switch branches, but you don't want to commit what you've "
"been working on yet, so you'll stash the changes.\n"
"To push a new stash onto your stack, run `git stash` or `git stash push`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:50
#, no-wrap
msgid ""
"$ git stash\n"
"Saved working directory and index state \\\n"
"  \"WIP on master: 049d078 Create index file\"\n"
"HEAD is now at 049d078 Create index file\n"
"(To restore them type \"git stash apply\")\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:53
#, no-wrap
msgid "You can now see that your working directory is clean:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:59
#, no-wrap
msgid ""
"$ git status\n"
"# On branch master\n"
"nothing to commit, working directory clean\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:63
#, no-wrap
msgid ""
"At this point, you can switch branches and do work elsewhere; your changes "
"are stored on your stack.\n"
"To see which stashes you've stored, you can use `git stash list`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:70
#, no-wrap
msgid ""
"$ git stash list\n"
"stash@{0}: WIP on master: 049d078 Create index file\n"
"stash@{1}: WIP on master: c264051 Revert \"Add file_size\"\n"
"stash@{2}: WIP on master: 21d80a5 Add number to log\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:76
#, no-wrap
msgid ""
"In this case, two stashes were saved previously, so you have access to three "
"different stashed works.\n"
"You can reapply the one you just stashed by using the command shown in the "
"help output of the original stash command: `git stash apply`.\n"
"If you want to apply one of the older stashes, you can specify it by naming "
"it, like this: `git stash apply stash@{2}`.\n"
"If you don't specify a stash, Git assumes the most recent stash and tries to "
"apply it:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:84
#, no-wrap
msgid ""
"$ git stash apply\n"
"On branch master\n"
"Changes not staged for commit:\n"
"  (use \"git add <file>...\" to update what will be committed)\n"
"  (use \"git checkout -- <file>...\" to discard changes in working "
"directory)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:87
#, no-wrap
msgid ""
"\tmodified:   index.html\n"
"\tmodified:   lib/simplegit.rb\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:89
#: book/07-git-tools/sections/submodules.asc:302
#: book/07-git-tools/sections/submodules.asc:416
#, no-wrap
msgid ""
"no changes added to commit (use \"git add\" and/or \"git commit -a\")\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:96
#, no-wrap
msgid ""
"You can see that Git re-modifies the files you reverted when you saved the "
"stash.\n"
"In this case, you had a clean working directory when you tried to apply the "
"stash, and you tried to apply it on the same branch you saved it from.\n"
"Having a clean working directory and applying it on the same branch aren't "
"necessary to successfully apply a stash.\n"
"You can save a stash on one branch, switch to another branch later, and try "
"to reapply the changes.\n"
"You can also have modified and uncommitted files in your working directory "
"when you apply a stash -- Git gives you merge conflicts if anything no "
"longer applies cleanly.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:100
#, no-wrap
msgid ""
"The changes to your files were reapplied, but the file you staged before "
"wasn't restaged.\n"
"To do that, you must run the `git stash apply` command with a `--index` "
"option to tell the command to try to reapply the staged changes.\n"
"If you had run that instead, you'd have gotten back to your original "
"position:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:107
#, no-wrap
msgid ""
"$ git stash apply --index\n"
"On branch master\n"
"Changes to be committed:\n"
"  (use \"git reset HEAD <file>...\" to unstage)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:119
#, no-wrap
msgid ""
"The apply option only tries to apply the stashed work -- you continue to "
"have it on your stack.\n"
"To remove it, you can run `git stash drop` with the name of the stash to "
"remove:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:128
#, no-wrap
msgid ""
"$ git stash list\n"
"stash@{0}: WIP on master: 049d078 Create index file\n"
"stash@{1}: WIP on master: c264051 Revert \"Add file_size\"\n"
"stash@{2}: WIP on master: 21d80a5 Add number to log\n"
"$ git stash drop stash@{0}\n"
"Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:131
#, no-wrap
msgid ""
"You can also run `git stash pop` to apply the stash and then immediately "
"drop it from your stack.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:133
#, no-wrap
msgid "==== Creative Stashing\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:137
#, no-wrap
msgid ""
"There are a few stash variants that may also be helpful.\n"
"The first option that is quite popular is the `--keep-index` option to the "
"`git stash` command.\n"
"This tells Git to not only include all staged content in the stash being "
"created, but simultaneously leave it in the index.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:143
#, no-wrap
msgid ""
"$ git status -s\n"
"M  index.html\n"
" M lib/simplegit.rb\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:147
#, no-wrap
msgid ""
"$ git stash --keep-index\n"
"Saved working directory and index state WIP on master: 1b65b17 added the "
"index file\n"
"HEAD is now at 1b65b17 added the index file\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:150
#, no-wrap
msgid ""
"$ git status -s\n"
"M  index.html\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:156
#, no-wrap
msgid ""
"Another common thing you may want to do with stash is to stash the untracked "
"files as well as the tracked ones.\n"
"By default, `git stash` will stash only modified and staged _tracked_ "
"files.\n"
"If you specify `--include-untracked` or `-u`, Git will include untracked "
"files in the stash being created.\n"
"However, including untracked files in the stash will still not include "
"explicitly _ignored_ files; to additionally include ignored files, use "
"`--all` (or just `-a`).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:163
#, no-wrap
msgid ""
"$ git status -s\n"
"M  index.html\n"
" M lib/simplegit.rb\n"
"?? new-file.txt\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:167
#, no-wrap
msgid ""
"$ git stash -u\n"
"Saved working directory and index state WIP on master: 1b65b17 added the "
"index file\n"
"HEAD is now at 1b65b17 added the index file\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:170
#, no-wrap
msgid ""
"$ git status -s\n"
"$\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:173
#, no-wrap
msgid ""
"Finally, if you specify the `--patch` flag, Git will not stash everything "
"that is modified but will instead prompt you interactively which of the "
"changes you would like to stash and which you would like to keep in your "
"working directory.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:189
#, no-wrap
msgid ""
"$ git stash --patch\n"
"diff --git a/lib/simplegit.rb b/lib/simplegit.rb\n"
"index 66d332e..8bb5674 100644\n"
"--- a/lib/simplegit.rb\n"
"+++ b/lib/simplegit.rb\n"
"@@ -16,6 +16,10 @@ class SimpleGit\n"
"         return `#{git_cmd} 2>&1`.chomp\n"
"       end\n"
"     end\n"
"+\n"
"+    def show(treeish = 'master')\n"
"+      command(\"git show #{treeish}\")\n"
"+    end\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:193
#, no-wrap
msgid ""
" end\n"
" test\n"
"Stash this hunk [y,n,q,a,d,/,e,?]? y\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:195
#, no-wrap
msgid ""
"Saved working directory and index state WIP on master: 1b65b17 added the "
"index file\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:198
#, no-wrap
msgid "==== Creating a Branch from a Stash\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:202
#, no-wrap
msgid ""
"If you stash some work, leave it there for a while, and continue on the "
"branch from which you stashed the work, you may have a problem reapplying "
"the work.\n"
"If the apply tries to modify a file that you've since modified, you'll get a "
"merge conflict and will have to try to resolve it.\n"
"If you want an easier way to test the stashed changes again, you can run "
"`git stash branch <new branchname>`, which creates a new branch for you with "
"your selected branch name, checks out the commit you were on when you "
"stashed your work, reapplies your work there, and then drops the stash if it "
"applies successfully:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:212
#, no-wrap
msgid ""
"$ git stash branch testchanges\n"
"M\tindex.html\n"
"M\tlib/simplegit.rb\n"
"Switched to a new branch 'testchanges'\n"
"On branch testchanges\n"
"Changes to be committed:\n"
"  (use \"git reset HEAD <file>...\" to unstage)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:220
#, no-wrap
msgid "\tmodified:   lib/simplegit.rb\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:222
#, no-wrap
msgid ""
"Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:225
#, no-wrap
msgid ""
"This is a nice shortcut to recover stashed work easily and work on it in a "
"new branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:228
#, no-wrap
msgid ""
"[[_git_clean]]\n"
"==== Cleaning your Working Directory\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:230
#, no-wrap
msgid ""
"Finally, you may not want to stash some work or files in your working "
"directory, but simply get rid of them; that's what the `git clean` command "
"is for.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:232
#, no-wrap
msgid ""
"Some common reasons for cleaning your working directory might be to remove "
"cruft that has been generated by merges or external tools or to remove build "
"artifacts in order to run a clean build.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:236
#, no-wrap
msgid ""
"You'll want to be pretty careful with this command, since it's designed to "
"remove files from your working directory that are not tracked.\n"
"If you change your mind, there is often no retrieving the content of those "
"files.\n"
"A safer option is to run `git stash --all` to remove everything but save it "
"in a stash.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:240
#, no-wrap
msgid ""
"Assuming you do want to remove cruft files or clean your working directory, "
"you can do so with `git clean`.\n"
"To remove all the untracked files in your working directory, you can run "
"`git clean -f -d`, which removes any files and also any subdirectories that "
"become empty as a result.\n"
"The `-f` means 'force' or \"`really do this,`\" and is required if the Git "
"configuration variable `clean.requireForce` is not explicitly set to "
"false.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:242
#, no-wrap
msgid ""
"If you ever want to see what it would do, you can run the command with the "
"`--dry-run` (or `-n`) option, which means \"`do a dry run and tell me what "
"you _would_ have removed`\".\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:248
#, no-wrap
msgid ""
"$ git clean -d -n\n"
"Would remove test.o\n"
"Would remove tmp/\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:253
#, no-wrap
msgid ""
"By default, the `git clean` command will only remove untracked files that "
"are not ignored.\n"
"Any file that matches a pattern in your `.gitignore` or other ignore files "
"will not be removed.\n"
"If you want to remove those files too, such as to remove all `.o` files "
"generated from a build so you can do a fully clean build, you can add a `-x` "
"to the clean command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:260
#, no-wrap
msgid ""
"$ git status -s\n"
" M lib/simplegit.rb\n"
"?? build.TMP\n"
"?? tmp/\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:264
#, no-wrap
msgid ""
"$ git clean -n -d\n"
"Would remove build.TMP\n"
"Would remove tmp/\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:269
#, no-wrap
msgid ""
"$ git clean -n -d -x\n"
"Would remove build.TMP\n"
"Would remove test.o\n"
"Would remove tmp/\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:273
#, no-wrap
msgid ""
"If you don't know what the `git clean` command is going to do, always run it "
"with a `-n` first to double check before changing the `-n` to a `-f` and "
"doing it for real.\n"
"The other way you can be careful about the process is to run it with the "
"`-i` or \"`interactive`\" flag.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:275
#, no-wrap
msgid "This will run the clean command in an interactive mode.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:285
#, no-wrap
msgid ""
"$ git clean -x -i\n"
"Would remove the following items:\n"
"  build.TMP  test.o\n"
"*** Commands ***\n"
"    1: clean                2: filter by pattern    3: select by numbers    "
"4: ask each             5: quit\n"
"    6: help\n"
"What now>\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:288
#, no-wrap
msgid ""
"This way you can step through each file individually or specify patterns for "
"deletion interactively.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/stashing-cleaning.asc:294
#, no-wrap
msgid ""
"There is a quirky situation where you might need to be extra forceful in "
"asking Git to clean your working directory.\n"
"If you happen to be in a working directory under which you've copied or "
"cloned other Git repositories (perhaps as submodules), even `git clean -fd` "
"will refuse to delete those directories.\n"
"In cases like that, you need to add a second `-f` option for emphasis.\n"
"====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:3
#, no-wrap
msgid ""
"[[_git_submodules]]\n"
"=== Submodules\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:7
#, no-wrap
msgid ""
"It often happens that while working on one project, you need to use another "
"project from within it.\n"
"Perhaps it's a library that a third party developed or that you're "
"developing separately and using in multiple parent projects.\n"
"A common issue arises in these scenarios: you want to be able to treat the "
"two projects as separate yet still be able to use one from within the "
"other.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:14
#, no-wrap
msgid ""
"Here's an example.\n"
"Suppose you're developing a website and creating Atom feeds.\n"
"Instead of writing your own Atom-generating code, you decide to use a "
"library.\n"
"You're likely to have to either include this code from a shared library like "
"a CPAN install or Ruby gem, or copy the source code into your own project "
"tree.\n"
"The issue with including the library is that it's difficult to customize the "
"library in any way and often more difficult to deploy it, because you need "
"to make sure every client has that library available.\n"
"The issue with copying the code into your own project is that any custom "
"changes you make are difficult to merge when upstream changes become "
"available.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:18
#, no-wrap
msgid ""
"Git addresses this issue using submodules.\n"
"Submodules allow you to keep a Git repository as a subdirectory of another "
"Git repository.\n"
"This lets you clone another repository into your project and keep your "
"commits separate.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:21
#, no-wrap
msgid ""
"[[_starting_submodules]]\n"
"==== Starting with Submodules\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:23
#, no-wrap
msgid ""
"We'll walk through developing a simple project that has been split up into a "
"main project and a few sub-projects.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:27
#, no-wrap
msgid ""
"Let's start by adding an existing Git repository as a submodule of the "
"repository that we're working on.\n"
"To add a new submodule you use the `git submodule add` command with the "
"absolute or relative URL of the project you would like to start tracking.\n"
"In this example, we'll add a library called \"`DbConnector`\".\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:37
#, no-wrap
msgid ""
"$ git submodule add https://github.com/chaconinc/DbConnector\n"
"Cloning into 'DbConnector'...\n"
"remote: Counting objects: 11, done.\n"
"remote: Compressing objects: 100% (10/10), done.\n"
"remote: Total 11 (delta 0), reused 11 (delta 0)\n"
"Unpacking objects: 100% (11/11), done.\n"
"Checking connectivity... done.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:41
#, no-wrap
msgid ""
"By default, submodules will add the subproject into a directory named the "
"same as the repository, in this case \"`DbConnector`\".\n"
"You can add a different path at the end of the command if you want it to go "
"elsewhere.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:43
#, no-wrap
msgid "If you run `git status` at this point, you'll notice a few things.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:49
#: book/07-git-tools/sections/submodules.asc:293
#: book/07-git-tools/sections/submodules.asc:313
#: book/07-git-tools/sections/submodules.asc:910
#: book/07-git-tools/sections/submodules.asc:967
#, no-wrap
msgid ""
"$ git status\n"
"On branch master\n"
"Your branch is up-to-date with 'origin/master'.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:52
#, no-wrap
msgid ""
"Changes to be committed:\n"
"  (use \"git reset HEAD <file>...\" to unstage)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:55
#, no-wrap
msgid ""
"\tnew file:   .gitmodules\n"
"\tnew file:   DbConnector\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:59
#, no-wrap
msgid ""
"First you should notice the new `.gitmodules` file.\n"
"This is a configuration file that stores the mapping between the project's "
"URL and the local subdirectory you've pulled it into:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:65
#, no-wrap
msgid ""
"[submodule \"DbConnector\"]\n"
"\tpath = DbConnector\n"
"\turl = https://github.com/chaconinc/DbConnector\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:71
#, no-wrap
msgid ""
"If you have multiple submodules, you'll have multiple entries in this "
"file.\n"
"It's important to note that this file is version-controlled with your other "
"files, like your `.gitignore` file.\n"
"It's pushed and pulled with the rest of your project.\n"
"This is how other people who clone this project know where to get the "
"submodule projects from.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:78
#, no-wrap
msgid ""
"Since the URL in the .gitmodules file is what other people will first try to "
"clone/fetch from, make sure to use a URL that they can access if possible.\n"
"For example, if you use a different URL to push to than others would to pull "
"from, use the one that others have access to.\n"
"You can overwrite this value locally with `git config "
"submodule.DbConnector.url PRIVATE_URL` for your own use.\n"
"When applicable, a relative URL can be helpful.\n"
"=====\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:82
#, no-wrap
msgid ""
"The other listing in the `git status` output is the project folder entry.\n"
"If you run `git diff` on that, you see something interesting:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:93
#, no-wrap
msgid ""
"$ git diff --cached DbConnector\n"
"diff --git a/DbConnector b/DbConnector\n"
"new file mode 160000\n"
"index 0000000..c3f01dc\n"
"--- /dev/null\n"
"+++ b/DbConnector\n"
"@@ -0,0 +1 @@\n"
"+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:97
#, no-wrap
msgid ""
"Although `DbConnector` is a subdirectory in your working directory, Git sees "
"it as a submodule and doesn't track its contents when you're not in that "
"directory.\n"
"Instead, Git sees it as a particular commit from that repository.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:99
#, no-wrap
msgid ""
"If you want a little nicer diff output, you can pass the `--submodule` "
"option to `git diff`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:113
#, no-wrap
msgid ""
"$ git diff --cached --submodule\n"
"diff --git a/.gitmodules b/.gitmodules\n"
"new file mode 100644\n"
"index 0000000..71fc376\n"
"--- /dev/null\n"
"+++ b/.gitmodules\n"
"@@ -0,0 +1,3 @@\n"
"+[submodule \"DbConnector\"]\n"
"+       path = DbConnector\n"
"+       url = https://github.com/chaconinc/DbConnector\n"
"Submodule DbConnector 0000000...c3f01dc (new submodule)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:116
#, no-wrap
msgid "When you commit, you see something like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:124
#, no-wrap
msgid ""
"$ git commit -am 'Add DbConnector module'\n"
"[master fb9093c] Add DbConnector module\n"
" 2 files changed, 4 insertions(+)\n"
" create mode 100644 .gitmodules\n"
" create mode 160000 DbConnector\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:128
#, no-wrap
msgid ""
"Notice the `160000` mode for the `DbConnector` entry.\n"
"That is a special mode in Git that basically means you're recording a commit "
"as a directory entry rather than a subdirectory or a file.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:130
#, no-wrap
msgid "Lastly, push these changes:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:134
#, no-wrap
msgid ""
"$ git push origin master\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:138
#, no-wrap
msgid ""
"[[_cloning_submodules]]\n"
"==== Cloning a Project with Submodules\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:141
#, no-wrap
msgid ""
"Here we'll clone a project with a submodule in it.\n"
"When you clone such a project, by default you get the directories that "
"contain submodules, but none of the files within them yet:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:166
#, no-wrap
msgid ""
"$ git clone https://github.com/chaconinc/MainProject\n"
"Cloning into 'MainProject'...\n"
"remote: Counting objects: 14, done.\n"
"remote: Compressing objects: 100% (13/13), done.\n"
"remote: Total 14 (delta 1), reused 13 (delta 0)\n"
"Unpacking objects: 100% (14/14), done.\n"
"Checking connectivity... done.\n"
"$ cd MainProject\n"
"$ ls -la\n"
"total 16\n"
"drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .\n"
"drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..\n"
"drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git\n"
"-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules\n"
"drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector\n"
"-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile\n"
"drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes\n"
"drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts\n"
"drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src\n"
"$ cd DbConnector/\n"
"$ ls\n"
"$\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:170
#, no-wrap
msgid ""
"The `DbConnector` directory is there, but empty.\n"
"You must run two commands: `git submodule init` to initialize your local "
"configuration file, and `git submodule update` to fetch all the data from "
"that project and check out the appropriate commit listed in your "
"superproject:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:183
#, no-wrap
msgid ""
"$ git submodule init\n"
"Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) "
"registered for path 'DbConnector'\n"
"$ git submodule update\n"
"Cloning into 'DbConnector'...\n"
"remote: Counting objects: 11, done.\n"
"remote: Compressing objects: 100% (10/10), done.\n"
"remote: Total 11 (delta 0), reused 11 (delta 0)\n"
"Unpacking objects: 100% (11/11), done.\n"
"Checking connectivity... done.\n"
"Submodule path 'DbConnector': checked out "
"'c3f01dc8862123d317dd46284b05b6892c7b29bc'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:186
#, no-wrap
msgid ""
"Now your `DbConnector` subdirectory is at the exact state it was in when you "
"committed earlier.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:189
#, no-wrap
msgid ""
"There is another way to do this which is a little simpler, however.\n"
"If you pass `--recurse-submodules` to the `git clone` command, it will "
"automatically initialize and update each submodule in the repository, "
"including nested submodules if any of the submodules in the repository have "
"submodules themselves.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:207
#, no-wrap
msgid ""
"$ git clone --recurse-submodules https://github.com/chaconinc/MainProject\n"
"Cloning into 'MainProject'...\n"
"remote: Counting objects: 14, done.\n"
"remote: Compressing objects: 100% (13/13), done.\n"
"remote: Total 14 (delta 1), reused 13 (delta 0)\n"
"Unpacking objects: 100% (14/14), done.\n"
"Checking connectivity... done.\n"
"Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) "
"registered for path 'DbConnector'\n"
"Cloning into 'DbConnector'...\n"
"remote: Counting objects: 11, done.\n"
"remote: Compressing objects: 100% (10/10), done.\n"
"remote: Total 11 (delta 0), reused 11 (delta 0)\n"
"Unpacking objects: 100% (11/11), done.\n"
"Checking connectivity... done.\n"
"Submodule path 'DbConnector': checked out "
"'c3f01dc8862123d317dd46284b05b6892c7b29bc'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:211
#, no-wrap
msgid ""
"If you already cloned the project and forgot `--recurse-submodules`, you can "
"combine the `git submodule init` and `git submodule update` steps by running "
"`git submodule update --init`.\n"
"To also initialize, fetch and checkout any nested submodules, you can use "
"the foolproof `git submodule update --init --recursive`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:213
#, no-wrap
msgid "==== Working on a Project with Submodules\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:215
#, no-wrap
msgid ""
"Now we have a copy of a project with submodules in it and will collaborate "
"with our teammates on both the main project and the submodule project.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:217
#, no-wrap
msgid "===== Pulling in Upstream Changes from the Submodule Remote\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:220
#, no-wrap
msgid ""
"The simplest model of using submodules in a project would be if you were "
"simply consuming a subproject and wanted to get updates from it from time to "
"time but were not actually modifying anything in your checkout.\n"
"Let's walk through a simple example there.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:222
#, no-wrap
msgid ""
"If you want to check for new work in a submodule, you can go into the "
"directory and run `git fetch` and `git merge` the upstream branch to update "
"the local code.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:234
#, no-wrap
msgid ""
"$ git fetch\n"
"From https://github.com/chaconinc/DbConnector\n"
"   c3f01dc..d0354fc  master     -> origin/master\n"
"$ git merge origin/master\n"
"Updating c3f01dc..d0354fc\n"
"Fast-forward\n"
" scripts/connect.sh | 1 +\n"
" src/db.c           | 1 +\n"
" 2 files changed, 2 insertions(+)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:238
#, no-wrap
msgid ""
"Now if you go back into the main project and run `git diff --submodule` you "
"can see that the submodule was updated and get a list of commits that were "
"added to it.\n"
"If you don't want to type `--submodule` every time you run `git diff`, you "
"can set it as the default format by setting the `diff.submodule` config "
"value to \"`log`\".\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:246
#, no-wrap
msgid ""
"$ git config --global diff.submodule log\n"
"$ git diff\n"
"Submodule DbConnector c3f01dc..d0354fc:\n"
"  > more efficient db routine\n"
"  > better connection routine\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:249
#, no-wrap
msgid ""
"If you commit at this point then you will lock the submodule into having the "
"new code when other people update.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:252
#, no-wrap
msgid ""
"There is an easier way to do this as well, if you prefer to not manually "
"fetch and merge in the subdirectory.\n"
"If you run `git submodule update --remote`, Git will go into your submodules "
"and fetch and update for you.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:263
#, no-wrap
msgid ""
"$ git submodule update --remote DbConnector\n"
"remote: Counting objects: 4, done.\n"
"remote: Compressing objects: 100% (2/2), done.\n"
"remote: Total 4 (delta 2), reused 4 (delta 2)\n"
"Unpacking objects: 100% (4/4), done.\n"
"From https://github.com/chaconinc/DbConnector\n"
"   3f19983..d0354fc  master     -> origin/master\n"
"Submodule path 'DbConnector': checked out "
"'d0354fc054692d3906c85c3af05ddce39a1c0644'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:269
#, no-wrap
msgid ""
"This command will by default assume that you want to update the checkout to "
"the `master` branch of the submodule repository.\n"
"You can, however, set this to something different if you want.\n"
"For example, if you want to have the DbConnector submodule track that "
"repository's \"`stable`\" branch, you can set it in either your "
"`.gitmodules` file (so everyone else also tracks it), or just in your local "
"`.git/config` file.\n"
"Let's set it in the `.gitmodules` file:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:273
#, no-wrap
msgid "$ git config -f .gitmodules submodule.DbConnector.branch stable\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:282
#, no-wrap
msgid ""
"$ git submodule update --remote\n"
"remote: Counting objects: 4, done.\n"
"remote: Compressing objects: 100% (2/2), done.\n"
"remote: Total 4 (delta 2), reused 4 (delta 2)\n"
"Unpacking objects: 100% (4/4), done.\n"
"From https://github.com/chaconinc/DbConnector\n"
"   27cf5d3..c87d55d  stable -> origin/stable\n"
"Submodule path 'DbConnector': checked out "
"'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:285
#, no-wrap
msgid ""
"If you leave off the `-f .gitmodules` it will only make the change for you, "
"but it probably makes more sense to track that information with the "
"repository so everyone else does as well.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:287
#, no-wrap
msgid ""
"When we run `git status` at this point, Git will show us that we have \"`new "
"commits`\" on the submodule.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:300
#, no-wrap
msgid ""
"  modified:   .gitmodules\n"
"  modified:   DbConnector (new commits)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:305
#, no-wrap
msgid ""
"If you set the configuration setting `status.submodulesummary`, Git will "
"also show you a short summary of changes to your submodules:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:309
#, no-wrap
msgid "$ git config status.submodulesummary 1\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:320
#, no-wrap
msgid ""
"\tmodified:   .gitmodules\n"
"\tmodified:   DbConnector (new commits)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:322
#: book/07-git-tools/sections/submodules.asc:408
#, no-wrap
msgid "Submodules changed but not updated:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:325
#, no-wrap
msgid ""
"* DbConnector c3f01dc...c87d55d (4):\n"
"  > catch non-null terminated lines\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:328
#, no-wrap
msgid ""
"At this point if you run `git diff` we can see both that we have modified "
"our `.gitmodules` file and also that there are a number of commits that "
"we've pulled down and are ready to commit to our submodule project.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:346
#, no-wrap
msgid ""
"$ git diff\n"
"diff --git a/.gitmodules b/.gitmodules\n"
"index 6fc0b3d..fd1cc29 100644\n"
"--- a/.gitmodules\n"
"+++ b/.gitmodules\n"
"@@ -1,3 +1,4 @@\n"
" [submodule \"DbConnector\"]\n"
"        path = DbConnector\n"
"        url = https://github.com/chaconinc/DbConnector\n"
"+       branch = stable\n"
" Submodule DbConnector c3f01dc..c87d55d:\n"
"  > catch non-null terminated lines\n"
"  > more robust error handling\n"
"  > more efficient db routine\n"
"  > better connection routine\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:350
#, no-wrap
msgid ""
"This is pretty cool as we can actually see the log of commits that we're "
"about to commit to in our submodule.\n"
"Once committed, you can see this information after the fact as well when you "
"run `git log -p`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:357
#, no-wrap
msgid ""
"$ git log -p --submodule\n"
"commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae\n"
"Author: Scott Chacon <schacon@gmail.com>\n"
"Date:   Wed Sep 17 16:37:02 2014 +0200\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:359
#, no-wrap
msgid "    updating DbConnector for bug fixes\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:374
#, no-wrap
msgid ""
"diff --git a/.gitmodules b/.gitmodules\n"
"index 6fc0b3d..fd1cc29 100644\n"
"--- a/.gitmodules\n"
"+++ b/.gitmodules\n"
"@@ -1,3 +1,4 @@\n"
" [submodule \"DbConnector\"]\n"
"        path = DbConnector\n"
"        url = https://github.com/chaconinc/DbConnector\n"
"+       branch = stable\n"
"Submodule DbConnector c3f01dc..c87d55d:\n"
"  > catch non-null terminated lines\n"
"  > more robust error handling\n"
"  > more efficient db routine\n"
"  > better connection routine\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:378
#, no-wrap
msgid ""
"Git will by default try to update *all* of your submodules when you run `git "
"submodule update --remote`.\n"
"If you have a lot of them, you may want to pass the name of just the "
"submodule you want to try to update.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:380
#, no-wrap
msgid "===== Pulling Upstream Changes from the Project Remote\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:383
#, no-wrap
msgid ""
"Let's now step into the shoes of your collaborator, who has their own local "
"clone of the MainProject repository.\n"
"Simply executing `git pull` to get your newly committed changes is not "
"enough:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:397
#, no-wrap
msgid ""
"$ git pull\n"
"From https://github.com/chaconinc/MainProject\n"
"   fb9093c..0a24cfc  master     -> origin/master\n"
"Fetching submodule DbConnector\n"
"From https://github.com/chaconinc/DbConnector\n"
"   c3f01dc..c87d55d  stable     -> origin/stable\n"
"Updating fb9093c..0a24cfc\n"
"Fast-forward\n"
" .gitmodules         | 2 +-\n"
" DbConnector         | 2 +-\n"
" 2 files changed, 2 insertions(+), 2 deletions(-)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:404
#, no-wrap
msgid ""
"$ git status\n"
" On branch master\n"
"Your branch is up-to-date with 'origin/master'.\n"
"Changes not staged for commit:\n"
"  (use \"git add <file>...\" to update what will be committed)\n"
"  (use \"git checkout -- <file>...\" to discard changes in working "
"directory)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:406
#, no-wrap
msgid "\tmodified:   DbConnector (new commits)\n"
msgstr ""

#. type: Bullet: '* '
#: book/07-git-tools/sections/submodules.asc:414
#, markdown-text, no-wrap
msgid ""
"DbConnector c87d55d...c3f01dc (4):\n"
"< catch non-null terminated lines\n"
"< more robust error handling\n"
"< more efficient db routine\n"
"< better connection routine\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:423
#, no-wrap
msgid ""
"By default, the  `git pull` command recursively fetches submodules changes, "
"as we can see in the output of the first command above.\n"
"However, it does not *update* the submodules.\n"
"This is shown by the output of the `git status` command, which shows the "
"submodule is \"`modified`\", and has \"`new commits`\".\n"
"What's more, the brackets showing the new commits point left (<), indicating "
"that these commits are recorded in MainProject but are not present in the "
"local DbConnector checkout.\n"
"To finalize the update, you need to run `git submodule update`:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:428
#, no-wrap
msgid ""
"$ git submodule update --init --recursive\n"
"Submodule path 'vendor/plugins/demo': checked out "
"'48679c6302815f6c76f1fe30625d795d9e55fc56'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:433
#, no-wrap
msgid ""
"$ git status\n"
" On branch master\n"
"Your branch is up-to-date with 'origin/master'.\n"
"nothing to commit, working tree clean\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:436
#, no-wrap
msgid ""
"Note that to be on the safe side, you should run `git submodule update` with "
"the `--init` flag in case the MainProject commits you just pulled added new "
"submodules, and with the `--recursive` flag if any submodules have nested "
"submodules.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:441
#, no-wrap
msgid ""
"If you want to automate this process, you can add "
"theÂ `--recurse-submodules` flag to the `git pull` command (since Git "
"2.14).\n"
"This will make Git run `git submodule update` right after the pull, putting "
"the submodules in the correct state.\n"
"Moreover, if you want to make Git always pull with `--recurse-submodules`, "
"you can set the configuration option `submodule.recurse` to true (this works "
"for `git pull` since Git 2.15).\n"
"This option will make Git use the `--recurse-submodules` flag for all "
"commands that support it (except `clone`).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:446
#, no-wrap
msgid ""
"There is a special situation that can happen when pulling superproject "
"updates: it could be that the upstream repository has changed the URL of the "
"submodule in the `.gitmodules` file in one of the commits you pull.\n"
"This can happen for example if the submodule project changes its hosting "
"platform.\n"
"In that case, it is possible for `git pull --recurse-submodules`, or `git "
"submodule update`, to fail if the superproject references a submodule commit "
"that is not found in the submodule remote locally configured in your "
"repository.\n"
"In order to remedy this situation, the `git submodule sync` command is "
"required:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:453
#, no-wrap
msgid ""
"# copy the new URL to your local config\n"
"$ git submodule sync --recursive\n"
"# update the submodule from the new URL\n"
"$ git submodule update --init --recursive\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:456
#, no-wrap
msgid "===== Working on a Submodule\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:459
#, no-wrap
msgid ""
"It's quite likely that if you're using submodules, you're doing so because "
"you really want to work on the code in the submodule at the same time as "
"you're working on the code in the main project (or across several "
"submodules).\n"
"Otherwise you would probably instead be using a simpler dependency "
"management system (such as Maven or Rubygems).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:461
#, no-wrap
msgid ""
"So now let's go through an example of making changes to the submodule at the "
"same time as the main project and committing and publishing those changes at "
"the same time.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:466
#, no-wrap
msgid ""
"So far, when we've run the `git submodule update` command to fetch changes "
"from the submodule repositories, Git would get the changes and update the "
"files in the subdirectory but will leave the sub-repository in what's called "
"a \"`detached HEAD`\" state.\n"
"This means that there is no local working branch (like `master`, for "
"example) tracking changes.\n"
"With no working branch tracking changes, that means even if you commit "
"changes to the submodule, those changes will quite possibly be lost the next "
"time you run `git submodule update`.\n"
"You have to do some extra steps if you want changes in a submodule to be "
"tracked.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:471
#, no-wrap
msgid ""
"In order to set up your submodule to be easier to go in and hack on, you "
"need to do two things.\n"
"You need to go into each submodule and check out a branch to work on.\n"
"Then you need to tell Git what to do if you have made changes and then `git "
"submodule update --remote` pulls in new work from upstream.\n"
"The options are that you can merge them into your local work, or you can try "
"to rebase your local work on top of the new changes.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:473
#, no-wrap
msgid ""
"First of all, let's go into our submodule directory and check out a "
"branch.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:479
#, no-wrap
msgid ""
"$ cd DbConnector/\n"
"$ git checkout stable\n"
"Switched to branch 'stable'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:484
#, no-wrap
msgid ""
"Let's try updating our submodule with the \"`merge`\" option.\n"
"To specify it manually, we can just add the `--merge` option to our `update` "
"call.\n"
"Here we'll see that there was a change on the server for this submodule and "
"it gets merged in.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:500
#, no-wrap
msgid ""
"$ cd ..\n"
"$ git submodule update --remote --merge\n"
"remote: Counting objects: 4, done.\n"
"remote: Compressing objects: 100% (2/2), done.\n"
"remote: Total 4 (delta 2), reused 4 (delta 2)\n"
"Unpacking objects: 100% (4/4), done.\n"
"From https://github.com/chaconinc/DbConnector\n"
"   c87d55d..92c7337  stable     -> origin/stable\n"
"Updating c87d55d..92c7337\n"
"Fast-forward\n"
" src/main.c | 1 +\n"
" 1 file changed, 1 insertion(+)\n"
"Submodule path 'DbConnector': merged in "
"'92c7337b30ef9e0893e758dac2459d07362ab5ea'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:504
#, no-wrap
msgid ""
"If we go into the DbConnector directory, we have the new changes already "
"merged into our local `stable` branch.\n"
"Now let's see what happens when we make our own local change to the library "
"and someone else pushes another change upstream at the same time.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:512
#, no-wrap
msgid ""
"$ cd DbConnector/\n"
"$ vim src/db.c\n"
"$ git commit -am 'Unicode support'\n"
"[stable f906e16] Unicode support\n"
" 1 file changed, 1 insertion(+)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:515
#, no-wrap
msgid ""
"Now if we update our submodule we can see what happens when we have made a "
"local change and upstream also has a change we need to incorporate.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:523
#, no-wrap
msgid ""
"$ cd ..\n"
"$ git submodule update --remote --rebase\n"
"First, rewinding head to replay your work on top of it...\n"
"Applying: Unicode support\n"
"Submodule path 'DbConnector': rebased into "
"'5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:526
#, no-wrap
msgid ""
"If you forget the `--rebase` or `--merge`, Git will just update the "
"submodule to whatever is on the server and reset your project to a detached "
"HEAD state.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:531
#, no-wrap
msgid ""
"$ git submodule update --remote\n"
"Submodule path 'DbConnector': checked out "
"'5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:534
#, no-wrap
msgid ""
"If this happens, don't worry, you can simply go back into the directory and "
"check out your branch again (which will still contain your work) and merge "
"or rebase `origin/stable` (or whatever remote branch you want) manually.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:536
#, no-wrap
msgid ""
"If you haven't committed your changes in your submodule and you run a "
"submodule update that would cause issues, Git will fetch the changes but not "
"overwrite unsaved work in your submodule directory.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:551
#, no-wrap
msgid ""
"$ git submodule update --remote\n"
"remote: Counting objects: 4, done.\n"
"remote: Compressing objects: 100% (3/3), done.\n"
"remote: Total 4 (delta 0), reused 4 (delta 0)\n"
"Unpacking objects: 100% (4/4), done.\n"
"From https://github.com/chaconinc/DbConnector\n"
"   5d60ef9..c75e92a  stable     -> origin/stable\n"
"error: Your local changes to the following files would be overwritten by "
"checkout:\n"
"\tscripts/setup.sh\n"
"Please, commit your changes or stash them before you can switch branches.\n"
"Aborting\n"
"Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule "
"path 'DbConnector'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:554
#, no-wrap
msgid ""
"If you made changes that conflict with something changed upstream, Git will "
"let you know when you run the update.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:563
#, no-wrap
msgid ""
"$ git submodule update --remote --merge\n"
"Auto-merging scripts/setup.sh\n"
"CONFLICT (content): Merge conflict in scripts/setup.sh\n"
"Recorded preimage for 'scripts/setup.sh'\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path "
"'DbConnector'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:566
#, no-wrap
msgid ""
"You can go into the submodule directory and fix the conflict just as you "
"normally would.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:569
#, no-wrap
msgid ""
"[[_publishing_submodules]]\n"
"===== Publishing Submodule Changes\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:572
#, no-wrap
msgid ""
"Now we have some changes in our submodule directory.\n"
"Some of these were brought in from upstream by our updates and others were "
"made locally and aren't available to anyone else yet as we haven't pushed "
"them yet.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:582
#, no-wrap
msgid ""
"$ git diff\n"
"Submodule DbConnector c87d55d..82d2ad3:\n"
"  > Merge from origin/stable\n"
"  > Update setup script\n"
"  > Unicode support\n"
"  > Remove unnecessary method\n"
"  > Add new option for conn pooling\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:586
#, no-wrap
msgid ""
"If we commit in the main project and push it up without pushing the "
"submodule changes up as well, other people who try to check out our changes "
"are going to be in trouble since they will have no way to get the submodule "
"changes that are depended on.\n"
"Those changes will only exist on our local copy.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:590
#, no-wrap
msgid ""
"In order to make sure this doesn't happen, you can ask Git to check that all "
"your submodules have been pushed properly before pushing the main project.\n"
"The `git push` command takes the `--recurse-submodules` argument which can "
"be set to either \"`check`\" or \"`on-demand`\".\n"
"The \"`check`\" option will make `push` simply fail if any of the committed "
"submodule changes haven't been pushed.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:597
#, no-wrap
msgid ""
"$ git push --recurse-submodules=check\n"
"The following submodule paths contain changes that can\n"
"not be found on any remote:\n"
"  DbConnector\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:599
#, no-wrap
msgid "Please try\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:601
#, no-wrap
msgid "\tgit push --recurse-submodules=on-demand\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:603
#, no-wrap
msgid "or cd to the path and use\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:605
#, no-wrap
msgid "\tgit push\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:607
#, no-wrap
msgid ""
"to push them to a remote.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:612
#, no-wrap
msgid ""
"As you can see, it also gives us some helpful advice on what we might want "
"to do next.\n"
"The simple option is to go into each submodule and manually push to the "
"remotes to make sure they're externally available and then try this push "
"again.\n"
"If you want the check behavior to happen for all pushes, you can make this "
"behavior the default by doing `git config push.recurseSubmodules check`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:614
#, no-wrap
msgid ""
"The other option is to use the \"`on-demand`\" value, which will try to do "
"this for you.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:633
#, no-wrap
msgid ""
"$ git push --recurse-submodules=on-demand\n"
"Pushing submodule 'DbConnector'\n"
"Counting objects: 9, done.\n"
"Delta compression using up to 8 threads.\n"
"Compressing objects: 100% (8/8), done.\n"
"Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.\n"
"Total 9 (delta 3), reused 0 (delta 0)\n"
"To https://github.com/chaconinc/DbConnector\n"
"   c75e92a..82d2ad3  stable -> stable\n"
"Counting objects: 2, done.\n"
"Delta compression using up to 8 threads.\n"
"Compressing objects: 100% (2/2), done.\n"
"Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.\n"
"Total 2 (delta 1), reused 0 (delta 0)\n"
"To https://github.com/chaconinc/MainProject\n"
"   3d6d338..9a377d1  master -> master\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:638
#, no-wrap
msgid ""
"As you can see there, Git went into the DbConnector module and pushed it "
"before pushing the main project.\n"
"If that submodule push fails for some reason, the main project push will "
"also fail.\n"
"You can make this behavior the default by doing `git config "
"push.recurseSubmodules on-demand`.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:640
#, no-wrap
msgid "===== Merging Submodule Changes\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:643
#, no-wrap
msgid ""
"If you change a submodule reference at the same time as someone else, you "
"may run into some problems.\n"
"That is, if the submodule histories have diverged and are committed to "
"diverging branches in a superproject, it may take a bit of work for you to "
"fix.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:645
#, no-wrap
msgid ""
"If one of the commits is a direct ancestor of the other (a fast-forward "
"merge), then Git will simply choose the latter for the merge, so that works "
"fine.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:648
#, no-wrap
msgid ""
"Git will not attempt even a trivial merge for you, however.\n"
"If the submodule commits diverge and need to be merged, you will get "
"something that looks like this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:663
#, no-wrap
msgid ""
"$ git pull\n"
"remote: Counting objects: 2, done.\n"
"remote: Compressing objects: 100% (1/1), done.\n"
"remote: Total 2 (delta 1), reused 2 (delta 1)\n"
"Unpacking objects: 100% (2/2), done.\n"
"From https://github.com/chaconinc/MainProject\n"
"   9a377d1..eb974f8  master     -> origin/master\n"
"Fetching submodule DbConnector\n"
"warning: Failed to merge submodule DbConnector (merge following commits not "
"found)\n"
"Auto-merging DbConnector\n"
"CONFLICT (submodule): Merge conflict in DbConnector\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:667
#, no-wrap
msgid ""
"So basically what has happened here is that Git has figured out that the two "
"branches record points in the submodule's history that are divergent and "
"need to be merged.\n"
"It explains it as \"`merge following commits not found`\", which is "
"confusing but we'll explain why that is in a bit.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:672
#, no-wrap
msgid ""
"To solve the problem, you need to figure out what state the submodule should "
"be in.\n"
"Strangely, Git doesn't really give you much information to help out here, "
"not even the SHA-1s of the commits of both sides of the history.\n"
"Fortunately, it's simple to figure out.\n"
"If you run `git diff` you can get the SHA-1s of the commits recorded in both "
"branches you were trying to merge.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:680
#, no-wrap
msgid ""
"$ git diff\n"
"diff --cc DbConnector\n"
"index eb41d76,c771610..0000000\n"
"--- a/DbConnector\n"
"+++ b/DbConnector\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:685
#, no-wrap
msgid ""
"So, in this case, `eb41d76` is the commit in our submodule that *we* had and "
"`c771610` is the commit that upstream had.\n"
"If we go into our submodule directory, it should already be on `eb41d76` as "
"the merge would not have touched it.\n"
"If for whatever reason it's not, you can simply create and checkout a branch "
"pointing to it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:690
#, no-wrap
msgid ""
"What is important is the SHA-1 of the commit from the other side.\n"
"This is what you'll have to merge in and resolve.\n"
"You can either just try the merge with the SHA-1 directly, or you can create "
"a branch for it and then try to merge that in.\n"
"We would suggest the latter, even if only to make a nicer merge commit "
"message.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:692
#, no-wrap
msgid ""
"So, we will go into our submodule directory, create a branch named "
"\"`try-merge`\" based on that second SHA-1 from `git diff`, and manually "
"merge.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:696
#, no-wrap
msgid "$ cd DbConnector\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:699
#, no-wrap
msgid ""
"$ git rev-parse HEAD\n"
"eb41d764bccf88be77aced643c13a7fa86714135\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:701
#, no-wrap
msgid "$ git branch try-merge c771610\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:707
#, no-wrap
msgid ""
"$ git merge try-merge\n"
"Auto-merging src/main.c\n"
"CONFLICT (content): Merge conflict in src/main.c\n"
"Recorded preimage for 'src/main.c'\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:710
#, no-wrap
msgid ""
"We got an actual merge conflict here, so if we resolve that and commit it, "
"then we can simply update the main project with the result.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:718
#, no-wrap
msgid ""
"$ vim src/main.c <1>\n"
"$ git add src/main.c\n"
"$ git commit -am 'merged our changes'\n"
"Recorded resolution for 'src/main.c'.\n"
"[master 9fd905e] merged our changes\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:730
#, no-wrap
msgid ""
"$ cd .. <2>\n"
"$ git diff <3>\n"
"diff --cc DbConnector\n"
"index eb41d76,c771610..0000000\n"
"--- a/DbConnector\n"
"+++ b/DbConnector\n"
"@@@ -1,1 -1,1 +1,1 @@@\n"
"- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135\n"
" -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d\n"
"++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a\n"
"$ git add DbConnector <4>\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:733
#, no-wrap
msgid ""
"$ git commit -m \"Merge Tom's Changes\" <5>\n"
"[master 10d2c60] Merge Tom's Changes\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:740
#, no-wrap
msgid ""
"<1> First we resolve the conflict.\n"
"<2> Then we go back to the main project directory.\n"
"<3> We can check the SHA-1s again.\n"
"<4> Resolve the conflicted submodule entry.\n"
"<5> Commit our merge.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:742
#, no-wrap
msgid "It can be a bit confusing, but it's really not very hard.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:746
#, no-wrap
msgid ""
"Interestingly, there is another case that Git handles.\n"
"If a merge commit exists in the submodule directory that contains *both* "
"commits in its history, Git will suggest it to you as a possible solution.\n"
"It sees that at some point in the submodule project, someone merged branches "
"containing these two commits, so maybe you'll want that one.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:749
#, no-wrap
msgid ""
"This is why the error message from before was \"`merge following commits not "
"found`\", because it could not do *this*.\n"
"It's confusing because who would expect it to *try* to do this?\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:751
#, no-wrap
msgid ""
"If it does find a single acceptable merge commit, you'll see something like "
"this:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:760
#, no-wrap
msgid ""
"$ git merge origin/master\n"
"warning: Failed to merge submodule DbConnector (not fast-forward)\n"
"Found a possible merge resolution for the submodule:\n"
" 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: > merged our changes\n"
"If this is correct simply add it to the index for example\n"
"by using:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:762
#, no-wrap
msgid ""
"  git update-index --cacheinfo 160000 "
"9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a \"DbConnector\"\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:767
#, no-wrap
msgid ""
"which will accept this suggestion.\n"
"Auto-merging DbConnector\n"
"CONFLICT (submodule): Merge conflict in DbConnector\n"
"Automatic merge failed; fix conflicts and then commit the result.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:772
#, no-wrap
msgid ""
"The suggested command Git is providing will update the index as though you "
"had run `git add` (which clears the conflict), then commit.\n"
"You probably shouldn't do this though.\n"
"You can just as easily go into the submodule directory, see what the "
"difference is, fast-forward to this commit, test it properly, and then "
"commit it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:779
#, no-wrap
msgid ""
"$ cd DbConnector/\n"
"$ git merge 9fd905e\n"
"Updating eb41d76..9fd905e\n"
"Fast-forward\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:783
#, no-wrap
msgid ""
"$ cd ..\n"
"$ git add DbConnector\n"
"$ git commit -am 'Fast forward to a common submodule child'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:786
#, no-wrap
msgid ""
"This accomplishes the same thing, but at least this way you can verify that "
"it works and you have the code in your submodule directory when you're "
"done.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:788
#, no-wrap
msgid "==== Submodule Tips\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:790
#, no-wrap
msgid ""
"There are a few things you can do to make working with submodules a little "
"easier.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:792
#, no-wrap
msgid "===== Submodule Foreach\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:795
#, no-wrap
msgid ""
"There is a `foreach` submodule command to run some arbitrary command in each "
"submodule.\n"
"This can be really helpful if you have a number of submodules in the same "
"project.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:798
#, no-wrap
msgid ""
"For example, let's say we want to start a new feature or do a bugfix and we "
"have work going on in several submodules.\n"
"We can easily stash all the work in all our submodules.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:807
#, no-wrap
msgid ""
"$ git submodule foreach 'git stash'\n"
"Entering 'CryptoLibrary'\n"
"No local changes to save\n"
"Entering 'DbConnector'\n"
"Saved working directory and index state WIP on stable: 82d2ad3 Merge from "
"origin/stable\n"
"HEAD is now at 82d2ad3 Merge from origin/stable\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:810
#, no-wrap
msgid "Then we can create a new branch and switch to it in all our submodules.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:818
#, no-wrap
msgid ""
"$ git submodule foreach 'git checkout -b featureA'\n"
"Entering 'CryptoLibrary'\n"
"Switched to a new branch 'featureA'\n"
"Entering 'DbConnector'\n"
"Switched to a new branch 'featureA'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:822
#, no-wrap
msgid ""
"You get the idea.\n"
"One really useful thing you can do is produce a nice unified diff of what is "
"changed in your main project and all your subprojects as well.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:832
#, no-wrap
msgid ""
"$ git diff; git submodule foreach 'git diff'\n"
"Submodule DbConnector contains modified content\n"
"diff --git a/src/main.c b/src/main.c\n"
"index 210f1ae..1f0acdc 100644\n"
"--- a/src/main.c\n"
"+++ b/src/main.c\n"
"@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char "
"***argv)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:834
#, no-wrap
msgid "      commit_pager_choice();\n"
msgstr ""

#. type: Bullet: '+     '
#: book/07-git-tools/sections/submodules.asc:848
#, markdown-text, no-wrap
msgid "url = url_decode(url_orig);\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:848
#, no-wrap
msgid ""
"+\n"
"      /* build alias_argv */\n"
"      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));\n"
"      alias_argv[0] = alias_string + 1;\n"
"Entering 'DbConnector'\n"
"diff --git a/src/db.c b/src/db.c\n"
"index 1aaefb6..5297645 100644\n"
"--- a/src/db.c\n"
"+++ b/src/db.c\n"
"@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)\n"
"        return url_decode_internal(&url, len, NULL, &out, 0);\n"
" }\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:857
#, no-wrap
msgid ""
"+char *url_decode(const char *url)\n"
"+{\n"
"+       return url_decode_mem(url, strlen(url));\n"
"+}\n"
"+\n"
" char *url_decode_parameter_name(const char **query)\n"
" {\n"
"        struct strbuf out = STRBUF_INIT;\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:861
#, no-wrap
msgid ""
"Here we can see that we're defining a function in a submodule and calling it "
"in the main project.\n"
"This is obviously a simplified example, but hopefully it gives you an idea "
"of how this may be useful.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:863
#, no-wrap
msgid "===== Useful Aliases\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:866
#, no-wrap
msgid ""
"You may want to set up some aliases for some of these commands as they can "
"be quite long and you can't set configuration options for most of them to "
"make them defaults.\n"
"We covered setting up Git aliases in "
"<<ch02-git-basics-chapter#_git_aliases>>, but here is an example of what you "
"may want to set up if you plan on working with submodules in Git a lot.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:872
#, no-wrap
msgid ""
"$ git config alias.sdiff '!'\"git diff && git submodule foreach 'git "
"diff'\"\n"
"$ git config alias.spush 'push --recurse-submodules=on-demand'\n"
"$ git config alias.supdate 'submodule update --remote --merge'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:875
#, no-wrap
msgid ""
"This way you can simply run `git supdate` when you want to update your "
"submodules, or `git spush` to push with submodule dependency checking.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:877
#, no-wrap
msgid "==== Issues with Submodules\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:879
#, no-wrap
msgid "Using submodules isn't without hiccups, however.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:881
#, no-wrap
msgid "===== Switching branches\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:884
#, no-wrap
msgid ""
"For instance, switching branches with submodules in them can also be tricky "
"with Git versions older than Git 2.13.\n"
"If you create a new branch, add a submodule there, and then switch back to a "
"branch without that submodule, you still have the submodule directory as an "
"untracked directory:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:889
#, no-wrap
msgid ""
"$ git --version\n"
"git version 2.12.2\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:892
#: book/07-git-tools/sections/submodules.asc:950
#, no-wrap
msgid ""
"$ git checkout -b add-crypto\n"
"Switched to a new branch 'add-crypto'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:896
#: book/07-git-tools/sections/submodules.asc:954
#, no-wrap
msgid ""
"$ git submodule add https://github.com/chaconinc/CryptoLibrary\n"
"Cloning into 'CryptoLibrary'...\n"
"...\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:901
#: book/07-git-tools/sections/submodules.asc:959
#, no-wrap
msgid ""
"$ git commit -am 'Add crypto library'\n"
"[add-crypto 4445836] Add crypto library\n"
" 2 files changed, 4 insertions(+)\n"
" create mode 160000 CryptoLibrary\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:906
#, no-wrap
msgid ""
"$ git checkout master\n"
"warning: unable to rmdir CryptoLibrary: Directory not empty\n"
"Switched to branch 'master'\n"
"Your branch is up-to-date with 'origin/master'.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:913
#, no-wrap
msgid ""
"Untracked files:\n"
"  (use \"git add <file>...\" to include in what will be committed)\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:915
#, no-wrap
msgid "\tCryptoLibrary/\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:917
#, no-wrap
msgid ""
"nothing added to commit but untracked files present (use \"git add\" to "
"track)\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:921
#, no-wrap
msgid ""
"Removing the directory isn't difficult, but it can be a bit confusing to "
"have that in there.\n"
"If you do remove it and then switch back to the branch that has that "
"submodule, you will need to run `submodule update --init` to repopulate "
"it.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:926
#, no-wrap
msgid ""
"$ git clean -ffdx\n"
"Removing CryptoLibrary/\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:929
#, no-wrap
msgid ""
"$ git checkout add-crypto\n"
"Switched to branch 'add-crypto'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:931
#, no-wrap
msgid "$ ls CryptoLibrary/\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:934
#, no-wrap
msgid ""
"$ git submodule update --init\n"
"Submodule path 'CryptoLibrary': checked out "
"'b8dda6aa182ea4464f3f3264b11e0268545172af'\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:937
#, no-wrap
msgid ""
"$ ls CryptoLibrary/\n"
"Makefile\tincludes\tscripts\t\tsrc\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:940
#, no-wrap
msgid "Again, not really very difficult, but it can be a little confusing.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:942
#, no-wrap
msgid ""
"Newer Git versions (Git >= 2.13) simplify all this by adding the "
"`--recurse-submodules` flag to the `git checkout` command, which takes care "
"of placing the submodules in the right state for the branch we are switching "
"to.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:947
#, no-wrap
msgid ""
"$ git --version\n"
"git version 2.13.3\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:963
#, no-wrap
msgid ""
"$ git checkout --recurse-submodules master\n"
"Switched to branch 'master'\n"
"Your branch is up-to-date with 'origin/master'.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:969
#, no-wrap
msgid ""
"nothing to commit, working tree clean\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:974
#, no-wrap
msgid ""
"Using the `--recurse-submodules` flag of `git checkout` can also be useful "
"when you work on several branches in the superproject, each having your "
"submodule pointing at different commits.\n"
"Indeed, if you switch between branches that record the submodule at "
"different commits, upon executing `git status` the submodule will appear as "
"\"`modified`\", and indicate \"`new commits`\".\n"
"That is because the submodule state is by default not carried over when "
"switching branches.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:977
#, no-wrap
msgid ""
"This can be really confusing, so it's a good idea to always `git checkout "
"--recurse-submodules` when your project has submodules.\n"
"For older Git versions that do not have the  `--recurse-submodules` flag, "
"after the checkout you can use `git submodule update --init --recursive` to "
"put the submodules in the right state.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:980
#, no-wrap
msgid ""
"Luckily, you can tell Git (>=2.14) to always use the  `--recurse-submodules` "
"flag by setting the configuration option `submodule.recurse`: `git config "
"submodule.recurse true`.\n"
"As noted above, this will also make Git recurse into submodules for every "
"command that has a `--recurse-submodules` option (except `git clone`).\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:982
#, no-wrap
msgid "===== Switching from subdirectories to submodules\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:987
#, no-wrap
msgid ""
"The other main caveat that many people run into involves switching from "
"subdirectories to submodules.\n"
"If you've been tracking files in your project and you want to move them out "
"into a submodule, you must be careful or Git will get angry at you.\n"
"Assume that you have files in a subdirectory of your project, and you want "
"to switch it to a submodule.\n"
"If you delete the subdirectory and then run `submodule add`, Git yells at "
"you:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:993
#, no-wrap
msgid ""
"$ rm -Rf CryptoLibrary/\n"
"$ git submodule add https://github.com/chaconinc/CryptoLibrary\n"
"'CryptoLibrary' already exists in the index\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:997
#, no-wrap
msgid ""
"You have to unstage the `CryptoLibrary` directory first.\n"
"Then you can add the submodule:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:1008
#, no-wrap
msgid ""
"$ git rm -r CryptoLibrary\n"
"$ git submodule add https://github.com/chaconinc/CryptoLibrary\n"
"Cloning into 'CryptoLibrary'...\n"
"remote: Counting objects: 11, done.\n"
"remote: Compressing objects: 100% (10/10), done.\n"
"remote: Total 11 (delta 0), reused 11 (delta 0)\n"
"Unpacking objects: 100% (11/11), done.\n"
"Checking connectivity... done.\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:1012
#, no-wrap
msgid ""
"Now suppose you did that in a branch.\n"
"If you try to switch back to a branch where those files are still in the "
"actual tree rather than a submodule â you get this error:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:1022
#, no-wrap
msgid ""
"$ git checkout master\n"
"error: The following untracked working tree files would be overwritten by "
"checkout:\n"
"  CryptoLibrary/Makefile\n"
"  CryptoLibrary/includes/crypto.h\n"
"  ...\n"
"Please move or remove them before you can switch branches.\n"
"Aborting\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:1025
#, no-wrap
msgid ""
"You can force it to switch with `checkout -f`, but be careful that you don't "
"have unsaved changes in there as they could be overwritten with that "
"command.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:1031
#, no-wrap
msgid ""
"$ git checkout -f master\n"
"warning: unable to rmdir CryptoLibrary: Directory not empty\n"
"Switched to branch 'master'\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:1036
#, no-wrap
msgid ""
"Then, when you switch back, you get an empty `CryptoLibrary` directory for "
"some reason and `git submodule update` may not fix it either.\n"
"You may need to go into your submodule directory and run a `git checkout .` "
"to get all your files back.\n"
"You could run this in a `submodule foreach` script to run it for multiple "
"submodules.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:1038
#, no-wrap
msgid ""
"It's important to note that submodules these days keep all their Git data in "
"the top project's `.git` directory, so unlike much older versions of Git, "
"destroying a submodule directory won't lose any commits or branches that you "
"had.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/submodules.asc:1039
#, no-wrap
msgid ""
"With these tools, submodules can be a fairly simple and effective method for "
"developing on several related but still separate projects simultaneously.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:3
#, no-wrap
msgid ""
"[[_subtree_merge]]\n"
"===== Subtree Merging\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:6
#, no-wrap
msgid ""
"The idea of the subtree merge is that you have two projects, and one of the "
"projects maps to a subdirectory of the other one.\n"
"When you specify a subtree merge, Git is often smart enough to figure out "
"that one is a subtree of the other and merge appropriately.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:8
#, no-wrap
msgid ""
"We'll go through an example of adding a separate project into an existing "
"project and then merging the code of the second into a subdirectory of the "
"first.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:11
#, no-wrap
msgid ""
"First, we'll add the Rack application to our project.\n"
"We'll add the Rack project as a remote reference in our own project and then "
"check it out into its own branch:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:30
#, no-wrap
msgid ""
"$ git remote add rack_remote https://github.com/rack/rack\n"
"$ git fetch rack_remote --no-tags\n"
"warning: no common commits\n"
"remote: Counting objects: 3184, done.\n"
"remote: Compressing objects: 100% (1465/1465), done.\n"
"remote: Total 3184 (delta 1952), reused 2770 (delta 1675)\n"
"Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.\n"
"Resolving deltas: 100% (1952/1952), done.\n"
"From https://github.com/rack/rack\n"
" * [new branch]      build      -> rack_remote/build\n"
" * [new branch]      master     -> rack_remote/master\n"
" * [new branch]      rack-0.4   -> rack_remote/rack-0.4\n"
" * [new branch]      rack-0.9   -> rack_remote/rack-0.9\n"
"$ git checkout -b rack_branch rack_remote/master\n"
"Branch rack_branch set up to track remote branch "
"refs/remotes/rack_remote/master.\n"
"Switched to a new branch \"rack_branch\"\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:34
#, no-wrap
msgid ""
"Now we have the root of the Rack project in our `rack_branch` branch and our "
"own project in the `master` branch.\n"
"If you check out one and then the other, you can see that they have "
"different project roots:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:44
#, no-wrap
msgid ""
"$ ls\n"
"AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib\n"
"COPYING         README         bin           example         test\n"
"$ git checkout master\n"
"Switched to branch \"master\"\n"
"$ ls\n"
"README\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:49
#, no-wrap
msgid ""
"This is sort of a strange concept.\n"
"Not all the branches in your repository actually have to be branches of the "
"same project.\n"
"It's not common, because it's rarely helpful, but it's fairly easy to have "
"branches contain completely different histories.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:54
#, no-wrap
msgid ""
"In this case, we want to pull the Rack project into our `master` project as "
"a subdirectory.\n"
"We can do that in Git with `git read-tree`.\n"
"You'll learn more about `read-tree` and its friends in "
"<<ch10-git-internals#ch10-git-internals>>, but for now know that it reads "
"the root tree of one branch into your current staging area and working "
"directory.\n"
"We just switched back to your `master` branch, and we pull the `rack_branch` "
"branch into the `rack` subdirectory of our `master` branch of our main "
"project:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:58
#, no-wrap
msgid ""
"$ git read-tree --prefix=rack/ -u rack_branch\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:63
#, no-wrap
msgid ""
"When we commit, it looks like we have all the Rack files under that "
"subdirectory â as though we copied them in from a tarball.\n"
"What gets interesting is that we can fairly easily merge changes from one of "
"the branches to the other.\n"
"So, if the Rack project updates, we can pull in upstream changes by "
"switching to that branch and pulling:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:68
#, no-wrap
msgid ""
"$ git checkout rack_branch\n"
"$ git pull\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:73
#, no-wrap
msgid ""
"Then, we can merge those changes back into our `master` branch.\n"
"To pull in the changes and prepopulate the commit message, use the "
"`--squash` option, as well as the recursive merge strategy's `-Xsubtree` "
"option.\n"
"The recursive strategy is the default here, but we include it for clarity.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:80
#, no-wrap
msgid ""
"$ git checkout master\n"
"$ git merge --squash -s recursive -Xsubtree=rack rack_branch\n"
"Squash commit -- not updating HEAD\n"
"Automatic merge went well; stopped before committing as requested\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:84
#, no-wrap
msgid ""
"All the changes from the Rack project are merged in and ready to be "
"committed locally.\n"
"You can also do the opposite â make changes in the `rack` subdirectory of "
"your `master` branch and then merge them into your `rack_branch` branch "
"later to submit them to the maintainers or push them upstream.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:89
#, no-wrap
msgid ""
"This gives us a way to have a workflow somewhat similar to the submodule "
"workflow without using submodules (which we will cover in "
"<<ch07-git-tools#_git_submodules>>).\n"
"We can keep branches with other related projects in our repository and "
"subtree merge them into our project occasionally.\n"
"It is nice in some ways, for example all the code is committed to a single "
"place.\n"
"However, it has other drawbacks in that it's a bit more complex and easier "
"to make mistakes in reintegrating changes or accidentally pushing a branch "
"into an unrelated repository.\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:92
#, no-wrap
msgid ""
"Another slightly weird thing is that to get a diff between what you have in "
"your `rack` subdirectory and the code in your `rack_branch` branch â to "
"see if you need to merge them â you can't use the normal `diff` command.\n"
"Instead, you must run `git diff-tree` with the branch you want to compare "
"to:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:96
#, no-wrap
msgid ""
"$ git diff-tree -p rack_branch\n"
"----\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:99
#, no-wrap
msgid ""
"Or, to compare what is in your `rack` subdirectory with what the `master` "
"branch on the server was the last time you fetched, you can run:\n"
msgstr ""

#. type: Plain text
#: book/07-git-tools/sections/subtree-merges.asc:103
#, no-wrap
msgid ""
"$ git diff-tree -p rack_remote/master\n"
"----\n"
msgstr ""
